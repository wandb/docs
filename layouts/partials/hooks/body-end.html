<script>
    // add line numbers and download buttons
    /*
    const preElements = document.querySelectorAll('pre');
    preElements.forEach(pre => {
      let codeTitle = pre.getAttribute('data-title');
      if (codeTitle) Prism.plugins.toolbar.registerButton('title', {
        text: codeTitle,
      });
    });
    */
    // show search keyword
    document.addEventListener("DOMContentLoaded", function () {
      // Function to sanitize input
      function sanitize(str) {
          const temp = document.createElement("div");
          temp.textContent = str;
          return temp.innerHTML;
      }
  
      // Get query string parameters
      const urlParams = new URLSearchParams(window.location.search);
      const queryValue = urlParams.get("q");
  
      // Check if 'q' has a value
      if (queryValue) {
          // Select the first h2 with class 'ms-4'
          const heading = document.querySelector("h2.ms-4");
          
          // Append the sanitized query value if the heading exists
          if (heading) {
              heading.textContent += `: "${sanitize(queryValue)}"`;
          }
      }
  });
  
  // Define the HTML with Font Awesome home icon
  const homeBreadcrumbHTML = `
    <li class="breadcrumb-item">
      <a aria-label="Home page" href="/">
        <i class="fa-solid fa-house" style="margin-right: 4px; font-size: 10px"></i>
      </a>
    </li>
  `;

  // Find the <ol> element with class 'breadcrumb'
  const breadcrumb = document.querySelector('ol.breadcrumb');

  // Only proceed if breadcrumb exists
  if (breadcrumb) {
    breadcrumb.insertAdjacentHTML('afterbegin', homeBreadcrumbHTML);
  }

  // right-nav scroll monitoring
  // Table of Contents Scroll Synchronization
class TOCScrollSync {
  constructor() {
    this.toc = document.getElementById('TableOfContents');
    this.tocLinks = [];
    this.headings = [];
    this.activeLink = null;
    this.isScrolling = false;
    this.scrollTimeout = null;
    
    this.init();
  }

  init() {
    if (!this.toc) {
      console.warn('Table of Contents not found');
      return;
    }

    // Collect all TOC links and their corresponding headings
    this.collectLinksAndHeadings();
    
    if (this.headings.length === 0) {
      console.warn('No headings found for TOC synchronization');
      return;
    }

    // Set up scroll listener with throttling
    this.setupScrollListener();
    
    // Initial check to set active link
    this.updateActiveLink();
  }

  collectLinksAndHeadings() {
    const links = this.toc.querySelectorAll('a[href^="#"]');
    
    links.forEach(link => {
      const href = link.getAttribute('href');
      const headingId = href.substring(1); // Remove the # symbol
      const heading = document.getElementById(headingId);
      
      if (heading) {
        this.tocLinks.push({
          link: link,
          heading: heading,
          id: headingId
        });
        this.headings.push(heading);
      }
    });
  }

  setupScrollListener() {
    // Throttled scroll handler for better performance
    const throttledScrollHandler = this.throttle(() => {
      this.updateActiveLink();
    }, 16); // ~60fps

    window.addEventListener('scroll', throttledScrollHandler, { passive: true });
    
    // Also listen for resize events in case content shifts
    window.addEventListener('resize', this.throttle(() => {
      this.updateActiveLink();
    }, 100));
  }

  updateActiveLink() {
    const scrollPosition = window.scrollY;
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;
    
    // If we're at the bottom of the page, activate the last heading
    if (scrollPosition + windowHeight >= documentHeight - 10) {
      this.setActiveLink(this.tocLinks[this.tocLinks.length - 1]);
      return;
    }

    // Find the current active heading
    let activeHeading = null;
    const offset = 300; // Offset from top to account for fixed headers, etc.

    // Check headings from top to bottom
    for (let i = 0; i < this.headings.length; i++) {
      const heading = this.headings[i];
      const headingTop = heading.offsetTop;
      
      // If this heading is above the scroll position + offset, it could be active
      if (headingTop <= scrollPosition + offset) {
        activeHeading = this.tocLinks[i];
      } else {
        // Once we find a heading that's below our scroll position, stop
        break;
      }
    }

    // If no heading is above our scroll position, check if we're near the top
    if (!activeHeading && this.tocLinks.length > 0) {
      const firstHeading = this.headings[0];
      const firstHeadingTop = firstHeading.offsetTop;
      
      // If we're above the first heading or very close to it, activate the first link
      if (scrollPosition + offset >= firstHeadingTop - 50) {
        activeHeading = this.tocLinks[0];
      }
    }

    this.setActiveLink(activeHeading);
  }

  setActiveLink(newActiveLink) {
    // Remove active class from current active link
    if (this.activeLink && this.activeLink !== newActiveLink) {
      this.activeLink.link.classList.remove('active');
    }

    // Set new active link
    if (newActiveLink && newActiveLink !== this.activeLink) {
      newActiveLink.link.classList.add('active');
      this.activeLink = newActiveLink;
    } else if (!newActiveLink && this.activeLink) {
      // Remove active class if no section is active
      this.activeLink.link.classList.remove('active');
      this.activeLink = null;
    }
  }

  // Utility function to throttle scroll events
  throttle(func, limit) {
    let inThrottle;
    return function() {
      const args = arguments;
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    }
  }

  // Public method to destroy the instance
  destroy() {
    // Remove event listeners if needed
    // (In a real implementation, you'd want to store references to remove them)
    console.log('TOC Scroll Sync destroyed');
  }
}

// Initialize the TOC scroll synchronization when the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  const tocSync = new TOCScrollSync();
  
  // Make it globally accessible if needed
  window.tocSync = tocSync;
});
  
</script>

{{- $topLevelItem := "" -}}
<!-- inject lvl0 value from top-tier menu name into Algolia -->
{{- $currentPage := . -}}
{{- range site.Menus.main -}}
  {{- if $currentPage.IsMenuCurrent .Menu . -}}
    {{- $topLevelItem := . }}
    <div class="lvl0" style="display:none">{{ $topLevelItem.Name }}</div>
  {{- else if $currentPage.HasMenuCurrent .Menu . -}}
    {{- $topLevelItem := . }}
    <div class="lvl0" style="display:none">{{ $topLevelItem.Name }}</div>
  {{- end -}}
{{- end -}}


{{- $lvl0 := "" -}}
{{- $lvl1 := "" -}}
{{- $current := . -}}

<!-- Step 1: Find the top-level menu item (lvl0) -->
{{- range site.Menus.main }}
  {{- if or ($current.IsMenuCurrent .Menu .) ($current.HasMenuCurrent .Menu .) }}
    {{- $lvl0 = . }}
  {{- end }}
{{- end }}

<!-- Step 2: Find lvl1 by looking at menu items that have lvl0 as a parent -->
{{- if $lvl0 }}
  {{- $ancestor := $current.Parent }}  <!-- Start at the parent page -->

  <!-- Check if the direct parent is in the menu -->
  {{- with $ancestor }}
    {{- range site.Menus.main }}
      {{- if and (eq .Parent $lvl0.Name) (.Page) (eq .Page $ancestor) }}
        {{- $lvl1 = . }}
      {{- end }}
    {{- end }}
  {{- end }}

  <!-- If lvl1 wasn't found, check one level higher -->
  {{- if and (not $lvl1) $ancestor.Parent }}
    {{- range site.Menus.main }}
      {{- if and (eq .Parent $lvl0.Name) (.Page) (eq .Page $ancestor.Parent) }}
        {{- $lvl1 = . }}
      {{- end }}
    {{- end }}
  {{- end }}
{{- end }}

<!-- Step 3: Output lvl0 and lvl1 -->
{{- if $lvl0 }}<div class="lvl0" style="display:none">{{ $lvl0.Name }}</div>{{- end }}
{{- if $lvl1 }}<div class="lvl1" style="display:none">{{ $lvl1.Name }}</div>{{- end }}


{{- if not hugo.IsProduction -}}
<!-- Segment & OneTrust: Staging -->
<!-- OneTrust Consent SDK Loader -->
<script
  src="https://cdn.cookielaw.org/consent/29d3f242-6917-42f4-a828-bac6fba2e677/otSDKStub.js"
  type="text/javascript"
  charset="UTF-8"
  data-domain-script="29d3f242-6917-42f4-a828-bac6fba2e677">
</script>

<!-- Your Consent Sync + Segment Loader -->
<script type="text/javascript">
  // Sync consent categories
  function wpConsentSync() {
    if (typeof OnetrustActiveGroups === 'undefined') return;

    const activeGroups = OnetrustActiveGroups || '';
    const hasGroup = (id) => activeGroups.includes(`,${id},`);
    const isOptIn = activeGroups === ',C0001,';

    window.wp_consent_type = isOptIn ? 'optin' : 'optout';
    document.dispatchEvent(new CustomEvent('wp_consent_type_defined'));

    const consentMap = {
      'statistics': hasGroup('C0002'),
      'statistics-anonymous': hasGroup('C0002'),
      'marketing': hasGroup('C0004') || hasGroup('C0005'),
      'functional': hasGroup('C0001') || hasGroup('C0003'),
      'preferences': false
    };

    if (typeof window.wp_set_consent === 'function') {
      for (const [category, allowed] of Object.entries(consentMap)) {
        window.wp_set_consent(category, allowed ? 'allow' : 'deny');
      }
    }

    // ðŸš€ Load Segment only if marketing or statistics consent is given
    if (consentMap.marketing || consentMap.statistics) {
      loadSegment();
    }
  }

  // Load Segment Analytics
  function loadSegment() {
    !function(){
      var analytics = window.analytics = window.analytics || [];
      if (!analytics.initialize)
        if (analytics.invoked)
          window.console && console.error && console.error("Segment snippet included twice.");
        else {
          analytics.invoked = !0;
          analytics.methods = [
            "trackSubmit", "trackClick", "trackLink", "trackForm", "pageview", "identify",
            "reset", "group", "track", "ready", "alias", "debug", "page", "once", "off", "on",
            "addSourceMiddleware", "addIntegrationMiddleware", "setAnonymousId", "addDestinationMiddleware"
          ];
          analytics.factory = function(method){
            return function(){
              if (window.analytics.initialized) return window.analytics[method].apply(window.analytics, arguments);
              var args = Array.prototype.slice.call(arguments);
              args.unshift(method);
              analytics.push(args);
              return analytics;
            }
          };
          for (var i = 0; i < analytics.methods.length; i++) {
            var key = analytics.methods[i];
            analytics[key] = analytics.factory(key);
          }
          analytics.load = function(writeKey, options){
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.async = true;
            script.src = "https://wandb.ai/sa-docs.min.js"; // <-- Your self-hosted Segment build
            var first = document.getElementsByTagName("script")[0];
            first.parentNode.insertBefore(script, first);
            analytics._loadOptions = options;
          };
          analytics._writeKey = "2r0Di0ymuP5ugdT6SM64JqH7T3zUXTDa"; // <-- Your real write key
          analytics.SNIPPET_VERSION = "4.16.1";
          analytics.load("2r0Di0ymuP5ugdT6SM64JqH7T3zUXTDa");

          // ðŸš€ Fire analytics.page() when ready
          analytics.ready(function() {
            analytics.page();
          });
        }
    }();
  }

  // Main hook called automatically by OneTrust
  function OptanonWrapper() {
    wpConsentSync();
    if (typeof Optanon !== 'undefined' && typeof Optanon.ShowBanner === 'function') {
      Optanon.ShowBanner();
    }
  }
</script>
{{- else -}}
<!-- Segment & Onetrust: Production -->
<!-- OneTrust Consent SDK Loader -->
<script
  src="https://cdn.cookielaw.org/consent/29d3f242-6917-42f4-a828-bac6fba2e677/otSDKStub.js"
  type="text/javascript"
  charset="UTF-8"
  data-domain-script="29d3f242-6917-42f4-a828-bac6fba2e677">
</script>

<!-- Your Consent Sync + Segment Loader -->
<script type="text/javascript">
  // Sync consent categories
  function wpConsentSync() {
    if (typeof OnetrustActiveGroups === 'undefined') return;

    const activeGroups = OnetrustActiveGroups || '';
    const hasGroup = (id) => activeGroups.includes(`,${id},`);
    const isOptIn = activeGroups === ',C0001,';

    window.wp_consent_type = isOptIn ? 'optin' : 'optout';
    document.dispatchEvent(new CustomEvent('wp_consent_type_defined'));

    const consentMap = {
      'statistics': hasGroup('C0002'),
      'statistics-anonymous': hasGroup('C0002'),
      'marketing': hasGroup('C0004') || hasGroup('C0005'),
      'functional': hasGroup('C0001') || hasGroup('C0003'),
      'preferences': false
    };

    if (typeof window.wp_set_consent === 'function') {
      for (const [category, allowed] of Object.entries(consentMap)) {
        window.wp_set_consent(category, allowed ? 'allow' : 'deny');
      }
    }

    // ðŸš€ Load Segment only if marketing or statistics consent is given
    if (consentMap.marketing || consentMap.statistics) {
      loadSegment();
    }
  }

  // Load Segment Analytics
  function loadSegment() {
    !function(){
      var analytics = window.analytics = window.analytics || [];
      if (!analytics.initialize)
        if (analytics.invoked)
          window.console && console.error && console.error("Segment snippet included twice.");
        else {
          analytics.invoked = !0;
          analytics.methods = [
            "trackSubmit", "trackClick", "trackLink", "trackForm", "pageview", "identify",
            "reset", "group", "track", "ready", "alias", "debug", "page", "once", "off", "on",
            "addSourceMiddleware", "addIntegrationMiddleware", "setAnonymousId", "addDestinationMiddleware"
          ];
          analytics.factory = function(method){
            return function(){
              if (window.analytics.initialized) return window.analytics[method].apply(window.analytics, arguments);
              var args = Array.prototype.slice.call(arguments);
              args.unshift(method);
              analytics.push(args);
              return analytics;
            }
          };
          for (var i = 0; i < analytics.methods.length; i++) {
            var key = analytics.methods[i];
            analytics[key] = analytics.factory(key);
          }
          analytics.load = function(writeKey, options){
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.async = true;
            script.src = "https://wandb.ai/sa-docs.min.js"; // <-- Your self-hosted Segment build
            var first = document.getElementsByTagName("script")[0];
            first.parentNode.insertBefore(script, first);
            analytics._loadOptions = options;
          };
          analytics._writeKey = "NYcqWZ8sgOCplYnItFyBaZ5ZRClWlVgl"; // <-- Your real write key
          analytics.SNIPPET_VERSION = "4.16.1";
          analytics.load("NYcqWZ8sgOCplYnItFyBaZ5ZRClWlVgl");

          // ðŸš€ Fire analytics.page() when ready
          analytics.ready(function() {
            analytics.page();
          });
        }
    }();
  }

  // Main hook called automatically by OneTrust
  function OptanonWrapper() {
    wpConsentSync();
    if (typeof Optanon !== 'undefined' && typeof Optanon.ShowBanner === 'function') {
      Optanon.ShowBanner();
    }
  }
</script>
{{- end -}}
