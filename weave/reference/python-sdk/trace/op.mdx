---
title: "op"
description: "Python SDK reference for weave.trace.op"
---


# API Overview

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L78"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

## <kbd>class</kbd> `DisplayNameFuncError`

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L81"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

## <kbd>class</kbd> `OpCallError`

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L186"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

## <kbd>class</kbd> `OpKwargs`
TypedDict for op() keyword arguments. 

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L91"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

## <kbd>class</kbd> `Sentinel`
Sentinel(package: 'str', path: 'str', name: 'str') 

<a href="https://github.com/wandb/weave/blob/v0.52.23/../../../../weave/trace/op/__init__"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>method</kbd> `__init__`

```python
__init__(package: 'str', path: 'str', name: 'str') → None
```

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L180"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

## <kbd>class</kbd> `WeaveKwargs`

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L1343"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `as_op`

```python
as_op(fn: 'Callable[P, R]') → Op[P, R]
```

Given a @weave.op decorated function, return its Op. 

@weave.op decorated functions are instances of Op already, so this function should be a no-op at runtime. But you can use it to satisfy type checkers if you need to access OpDef attributes in a typesafe way. 

**Args:**
 

 - <b>`fn`</b>: A weave.op decorated function.
**Returns:**
 The Op of the function. 

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L1092"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `call`

```python
call(
    op: 'Op',
    *args: 'Any',
    __weave: 'WeaveKwargs | None' = None,
    __should_raise: 'bool' = False,
    __require_explicit_finish: 'bool' = False,
    **kwargs: 'Any'
) → tuple[Any, Call] | Coroutine[Any, Any, tuple[Any, Call]]
```

Executes the op and returns both the result and a Call representing the execution. 

This function will never raise.  Any errors are captured in the Call object. 

This method is automatically bound to any function decorated with `@weave.op`, allowing for usage like: 

```python
@weave.op
def add(a: int, b: int) -> int:
     return a + b

result, call = add.call(1, 2)
```

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L1138"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `calls`

```python
calls(op: 'Op') → CallsIter
```

Get an iterator over all calls to this op. 

This method is automatically bound to any function decorated with `@weave.op`, allowing for usage like: 

```python
@weave.op
def add(a: int, b: int) -> int:
     return a + b

calls = add.calls()
for call in calls:
     print(call)
```

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L1289"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `get_captured_code`

```python
get_captured_code(op: 'Op') → str
```

Get the captured code of the op. 

This only works when you get an op back from a ref.  The pattern is: 

ref = weave.publish(func) op = ref.get() captured_code = op.get_captured_code() 

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L1335"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `is_op`

```python
is_op(obj: 'Any') → TypeIs[Op]
```

Check if an object is an Op. 

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L370"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `is_placeholder_call`

```python
is_placeholder_call(call: 'Call') → TypeIs[NoOpCall]
```

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L338"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `is_tracing_setting_disabled`

```python
is_tracing_setting_disabled() → bool
```

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L1306"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `maybe_bind_method`

```python
maybe_bind_method(func: 'Callable', self: 'Any' = None) → Callable | MethodType
```

Bind a function to any object (even if it's not a class). 

If self is None, return the function as is. 

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L1318"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `maybe_unbind_method`

```python
maybe_unbind_method(oplike: 'Op | MethodType | partial') → Op
```

Unbind an Op-like method or partial to a plain Op function. 

For: 
- methods, remove set `self` param 
- partials, remove any preset params 

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L1162"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `op`

```python
op(
    func: 'Callable[P, R] | None' = None,
    name: 'str | None' = None,
    call_display_name: 'str | CallDisplayNameFunc | None' = None,
    postprocess_inputs: 'PostprocessInputsFunc | None' = None,
    postprocess_output: 'PostprocessOutputFunc | None' = None,
    tracing_sample_rate: 'float' = 1.0,
    enable_code_capture: 'bool' = True,
    accumulator: 'Callable[[Any | None, Any], Any] | None' = None
) → Callable[[Callable[P, R]], Op[P, R]] | Op[P, R]
```

A decorator to weave op-ify a function or method. Works for both sync and async. Automatically detects iterator functions and applies appropriate behavior. 

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L363"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `placeholder_call`

```python
placeholder_call() → Call
```

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L198"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `setup_dunder_weave_dict`

```python
setup_dunder_weave_dict(d: 'WeaveKwargs | None' = None) → WeaveKwargs
```

Sets up a __weave dict used to pass WeaveKwargs to ops. 

---

<a href="https://github.com/wandb/weave/blob/v0.52.23/weave/trace/op.py#L349"><img align="right" src="https://img.shields.io/badge/-source-cccccc?style=flat-square" /></a>

### <kbd>function</kbd> `should_skip_tracing_for_op`

```python
should_skip_tracing_for_op(op: 'Op') → bool
```

