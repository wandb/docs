---
title: "Tracing Basics"
description: "Track and monitor your AI application's execution with Weave tracing"
---


<Frame>
![Weave Calls Screenshot](/images/screenshots/calls_macro.png)
</Frame>

<Frame>
![Weave Calls Screenshot](/images/screenshots/basic_call.png)
</Frame>

<Frame>
![Weave Calls Screenshot](/images/screenshots/calls_filter.png)
</Frame>


## Ops

An **Op** is a versioned, tracked function. When you decorate a function with `@weave.op()` (Python) or wrap it with `weave.op()` (TypeScript), Weave automatically captures its code, inputs, outputs, and execution metadata. Ops are the building blocks of tracing, evaluation scorers, and any tracked computation.
<CodeGroup>
```python Python
    @weave.op
    async def my_function(){
      ...  }
```

```typescript Typescript
function myFunction() {
    ...
}

const myFunctionOp = weave.op(myFunction)
```
</CodeGroup>




## Calls

A **Call** is a logged execution of an Op. Every time an Op runs, Weave creates a Call that captures:

- Input arguments
- Output value
- Timing and latency
- Parent-child relationships (for nested calls)
- Any errors that occurred

Calls form the backbone of Weave's tracing system and provide the data for debugging, analysis, and evaluation.


Calls are similar to spans in the [OpenTelemetry](https://opentelemetry.io) data model. A Call can:
- Belong to a Trace (a collection of calls in the same execution context)
- Have parent and child Calls, forming a tree structure


## FAQs

### How do I stop large traces from being truncated?

For more information, see [Trace data is truncated](/weave/guides/troubleshooting#trace-data-is-truncated) in the [Troubleshooting guide](/weave/guides/troubleshooting).


