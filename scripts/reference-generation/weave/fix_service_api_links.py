#!/usr/bin/env python3
"""
Fix Service API links in documentation to use fully qualified URLs.

Since Service API docs are dynamically generated by Mintlify from the OpenAPI spec,
internal links to specific endpoints will show as broken in lint checks.
This script converts them to fully qualified URLs.
"""

import re
from pathlib import Path
from typing import Set, Tuple


# Mapping of endpoint paths to their Mintlify documentation URLs
ENDPOINT_MAPPINGS = {
    # Calls
    "/call/start": "calls/call-start",
    "/call/end": "calls/call-end",
    "/call/read": "calls/call-read",
    "/call/update": "calls/call-update",
    "/call/upsert_batch": "calls/call-start-batch",
    "/calls/delete": "calls/calls-delete",
    "/calls/query_stats": "calls/calls-query-stats",
    "/calls/stream_query": "calls/calls-query-stream",
    
    # Costs
    "/cost/create": "costs/cost-create",
    "/cost/query": "costs/cost-query",
    "/cost/purge": "costs/cost-purge",
    
    # Feedback
    "/feedback/create": "feedback/feedback-create",
    "/feedback/query": "feedback/feedback-query",
    "/feedback/purge": "feedback/feedback-purge",
    "/feedback/replace": "feedback/feedback-replace",
    
    # Files
    "/file/create": "files/file-create",
    "/file/content": "files/file-content",
    "/files/query_stats": "files/files-stats",
    
    # Objects
    "/obj/create": "objects/obj-create",
    "/obj/read": "objects/obj-read",
    "/obj/delete": "objects/obj-delete",
    
    # OpenTelemetry
    "/otel/v1/traces": "opentelemetry/export-trace",
    
    # Refs
    "/refs/read_batch": "refs/refs-read-batch",
    
    # Service
    "/health": "service/read-root",
    "/version": "service/read-version",
    "/geolocate": "service/get-caller-location",
    "/server_info": "service/server-info",
    
    # Tables
    "/table/create": "tables/table-create",
    "/table/update": "tables/table-update",
    "/table/query": "tables/table-query",
    "/table/query_stats": "tables/table-query-stats",
    "/table/query_stats_batch": "tables/table-query-stats-batch",
    
    # Threads
    "/threads/stream_query": "threads/threads-query-stream",
}


def find_service_api_links(content: str) -> Set[Tuple[str, str]]:
    """
    Find all Service API links that need to be fixed.
    Returns set of (original_link, full_url) tuples.
    """
    links_to_fix = set()
    
    # Pattern 1: Links to /weave/reference/service-api/... (specific endpoints)
    # These should be fully qualified
    pattern1 = r'\[([^\]]+)\]\(/weave/reference/service-api/([^)#]+)(?:[#)])'
    for match in re.finditer(pattern1, content):
        endpoint_path = match.group(2)
        if endpoint_path and not endpoint_path.endswith('.mdx'):
            # This is likely a specific endpoint reference
            original = match.group(0)
            full_url = f"[{match.group(1)}](https://docs.wandb.ai/weave/reference/service-api/{endpoint_path})"
            links_to_fix.add((original, full_url))
    
    # Pattern 2: Links to /api-reference/... (old style)
    pattern2 = r'\[([^\]]+)\]\(/api-reference/([^)]+)\)'
    for match in re.finditer(pattern2, content):
        original = match.group(0)
        path = match.group(2)
        # Convert to new URL structure
        full_url = f"[{match.group(1)}](https://docs.wandb.ai/weave/reference/service-api/{path})"
        links_to_fix.add((original, full_url))
    
    # Pattern 3: Links that mention specific endpoints but link to general page
    # e.g., [POST /call/start](/weave/reference/service-api)
    pattern3 = r'\[(GET|POST|PUT|DELETE|PATCH)\s+([^]]+)\]\(/weave/reference/service-api\)'
    for match in re.finditer(pattern3, content):
        endpoint = match.group(2).strip()
        if endpoint in ENDPOINT_MAPPINGS:
            original = match.group(0)
            full_url = f"[{match.group(1)} {endpoint}](https://docs.wandb.ai/weave/reference/service-api/{ENDPOINT_MAPPINGS[endpoint]})"
            links_to_fix.add((original, full_url))
    
    return links_to_fix


def fix_service_api_links_in_file(file_path: Path) -> bool:
    """Fix Service API links in a single file."""
    with open(file_path, 'r') as f:
        content = f.read()
    
    original_content = content
    
    # Find all links that need fixing
    links_to_fix = find_service_api_links(content)
    
    # Apply fixes
    for original, fixed in links_to_fix:
        content = content.replace(original, fixed)
    
    # Special case: Don't fix links in the service-api.mdx landing page itself
    # Those should remain as fully qualified URLs
    if file_path.name == "service-api.mdx":
        return False
    
    # Write back if changed
    if content != original_content:
        with open(file_path, 'w') as f:
            f.write(content)
        return True
    return False


def main():
    """Fix Service API links in all MDX files."""
    # Find all MDX files in the weave directory
    weave_dir = Path('weave')
    mdx_files = list(weave_dir.rglob('*.mdx'))
    
    # Exclude the service-api reference directory itself
    mdx_files = [f for f in mdx_files if 'weave/reference/service-api/' not in str(f)]
    
    print(f"Checking {len(mdx_files)} MDX files for Service API links...")
    
    fixed_count = 0
    files_fixed = []
    
    for mdx_file in mdx_files:
        if fix_service_api_links_in_file(mdx_file):
            print(f"  ✓ Fixed Service API links in {mdx_file}")
            files_fixed.append(mdx_file)
            fixed_count += 1
    
    if fixed_count > 0:
        print(f"\n✓ Fixed Service API links in {fixed_count} files:")
        for f in files_fixed:
            print(f"  - {f}")
    else:
        print("\n✓ No Service API links needed fixing")
    
    return 0


if __name__ == "__main__":
    exit(main())
