name: Mintlify PR Preview Links

on:
  pull_request:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created, edited]
  workflow_run:
    workflows: ["Mintlify Deployment"]
    types: [completed]

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: read
  checks: read

jobs:
  preview-links:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' || 
      (github.event_name == 'workflow_run' && github.event.workflow_run.event == 'pull_request') ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, 'mintlify.app'))
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha || github.event.workflow_run.head_sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '18'

      - name: Get changed files
        id: changed
        uses: tj-actions/changed-files@v47
        with:
          files: |
            *.mdx
            **/*.mdx
            *.md
            **/*.md
            docs.json
            mint.json
            snippets/**
            images/**
            icons/**
            logo/**
            static/**
            style.css
          include_all_old_new_renamed_files: true

      - name: Find or create preview comment
        if: steps.changed.outputs.any_changed == 'true'
        id: find-comment
        uses: actions/github-script@v8
        with:
          script: |
            // Determine PR number based on event type
            let prNumber;
            if (context.eventName === 'pull_request') {
              prNumber = context.issue.number;
            } else if (context.eventName === 'issue_comment') {
              // For issue_comment on a PR
              if (context.payload.issue && context.payload.issue.pull_request) {
                prNumber = context.payload.issue.number;
              }
            } else if (context.eventName === 'workflow_run') {
              // For workflow_run, we need to find the PR number
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: context.payload.workflow_run.workflow_id,
                per_page: 1
              });
              
              if (runs.data.workflow_runs.length > 0) {
                const run = runs.data.workflow_runs[0];
                if (run.pull_requests && run.pull_requests.length > 0) {
                  prNumber = run.pull_requests[0].number;
                }
              }
            }
            
            if (!prNumber) {
              core.warning('Could not determine PR number');
              return;
            }
            
            core.setOutput('pr_number', prNumber);
            
            // Find or create comment
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });
            
            const existingComment = comments.find(c => /<!-- mintlify-preview-links -->/.test(c.body || ''));
            if (existingComment) {
              core.info(`Found existing preview comment: ${existingComment.id}`);
              core.setOutput('comment_id', existingComment.id);
              core.setOutput('comment_exists', 'true');
            } else {
              // Create placeholder comment
              const placeholderBody = `<!-- mintlify-preview-links -->\n<!-- preview-base:  -->\n**PR Preview: Changed content**\n\n‚è≥ *Generating preview links...*\n\n<sub>This comment will be automatically updated when Mintlify deployment finishes.</sub>`;
              
              const newComment = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: placeholderBody,
              });
              
              core.info(`Created placeholder preview comment: ${newComment.data.id}`);
              core.setOutput('comment_id', newComment.data.id);
              core.setOutput('comment_exists', 'false');
            }

      - name: Find Mintlify Preview URL
        if: steps.changed.outputs.any_changed == 'true'
        id: find-preview
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = parseInt('${{ steps.find-comment.outputs.pr_number }}');
            if (!prNumber) {
              core.warning('No PR number available');
              return;
            }
            
            async function getMintlifyPreviewUrl() {
              // Check timeline events for deployment
              try {
                const timeline = await github.rest.issues.listEventsForTimeline({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  per_page: 100
                });
                
                // Look for deployment events
                for (const event of timeline.data) {
                  if (event.event === 'deployed' || (event.event === 'commented' && event.actor && event.actor.login === 'mintlify[bot]')) {
                    const body = event.body || '';
                    // Look for Mintlify URLs in the event
                    const urlMatch = body.match(/https:\/\/[a-zA-Z0-9-]+\.mintlify\.app/);
                    if (urlMatch) {
                      core.info(`Found Mintlify URL in timeline: ${urlMatch[0]}`);
                      return urlMatch[0];
                    }
                  }
                }
              } catch (e) {
                core.info(`Could not fetch timeline: ${e.message}`);
              }
              
              // Check PR comments for Mintlify bot comment
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100,
              });
              
              // Sort comments by created date descending to check most recent first
              comments.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              
              for (const comment of comments) {
                // Look for any comment with a Mintlify URL
                const body = comment.body || '';
                const urlMatch = body.match(/https:\/\/[a-zA-Z0-9-]+\.mintlify\.app/);
                if (urlMatch) {
                  core.info(`Found Mintlify URL in comment from ${comment.user?.login}: ${urlMatch[0]}`);
                  return urlMatch[0];
                }
              }
              
              // Alternative: Check deployment statuses
              try {
                const deployments = await github.rest.repos.listDeployments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: context.payload.pull_request?.head.sha || context.sha,
                  per_page: 10
                });
                
                for (const deployment of deployments.data) {
                  if (deployment.environment === 'staging' || deployment.environment === 'preview') {
                    const statuses = await github.rest.repos.listDeploymentStatuses({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      deployment_id: deployment.id
                    });
                    
                    for (const status of statuses.data) {
                      if (status.environment_url && status.environment_url.includes('mintlify.app')) {
                        core.info(`Found deployment URL: ${status.environment_url}`);
                        return status.environment_url;
                      }
                    }
                  }
                }
              } catch (e) {
                core.info(`No deployment statuses found: ${e.message}`);
              }
              
              // Alternative: Get check runs for the PR
              try {
                const checkRuns = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: context.payload.pull_request?.head.sha || context.payload.workflow_run?.head_sha || context.sha,
                });
                
                // Look for Mintlify deployment check
                const mintlifyCheck = checkRuns.data.check_runs.find(
                  run => run.name === 'Mintlify Deployment' && run.status === 'completed'
                );
                
                if (!mintlifyCheck) {
                  core.info('Mintlify deployment check not found or not completed yet');
                  // Log all check names for debugging
                  const checkNames = checkRuns.data.check_runs.map(r => r.name);
                  core.info(`Available checks: ${checkNames.join(', ')}`);
                  return '';
                }
                
                // Extract URL from check output
                if (mintlifyCheck.output && mintlifyCheck.output.text) {
                  // Look for the preview URL in the output
                  const urlMatch = mintlifyCheck.output.text.match(/https:\/\/[a-zA-Z0-9-]+\.mintlify\.app/);
                  if (urlMatch) {
                    core.info(`Extracted URL from check output: ${urlMatch[0]}`);
                    return urlMatch[0];
                  }
                }
              } catch (e) {
                core.warning(`Error getting check runs: ${e.message}`);
              }
              
              return '';
            }
            
            // Try to get the preview URL with retries
            let previewUrl = '';
            const maxAttempts = 6; // 1 minute with 10 second intervals
            for (let i = 0; i < maxAttempts; i++) {
              previewUrl = await getMintlifyPreviewUrl();
              if (previewUrl) {
                core.info(`Found Mintlify preview URL: ${previewUrl}`);
                break;
              }
              
              if (i < maxAttempts - 1) {
                core.info(`Attempt ${i + 1}: Waiting for Mintlify deployment...`);
                await new Promise(r => setTimeout(r, 10000)); // Wait 10 seconds
              }
            }
            
            // Fallback: Use known Mintlify project URL if configured
            if (!previewUrl) {
              // This is the known Mintlify URL for the wandb/docs project
              // You can update this when the Mintlify project ID changes
              const fallbackUrl = 'https://wb-21fd5541.mintlify.app';
              core.warning(`Using fallback Mintlify URL: ${fallbackUrl}`);
              previewUrl = fallbackUrl;
            }
            
            core.setOutput('preview_url', previewUrl);

      - name: Update PR comment with preview links
        if: steps.changed.outputs.any_changed == 'true'
        uses: actions/github-script@v8
        env:
          ADDED: ${{ steps.changed.outputs.added_files }}
          MODIFIED: ${{ steps.changed.outputs.modified_files }}
          DELETED: ${{ steps.changed.outputs.deleted_files }}
          RENAMED: ${{ steps.changed.outputs.renamed_files }}
          RENAMED_PAIRS: ${{ steps.changed.outputs.all_old_new_renamed_files }}
          PREVIEW_URL: ${{ steps.find-preview.outputs.preview_url }}
          COMMENT_ID: ${{ steps.find-comment.outputs.comment_id }}
          PR_NUMBER: ${{ steps.find-comment.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            function splitList(s) {
              if (!s) return [];
              return s
                .split(/\r?\n|,|\s+/)
                .map(x => x.trim())
                .filter(Boolean);
            }
            
            const added = splitList(process.env.ADDED);
            const modified = splitList(process.env.MODIFIED);
            const deleted = splitList(process.env.DELETED);
            const renamedPairs = splitList(process.env.RENAMED_PAIRS);
            
            // Process renamed files
            const renamedFiles = [];
            const renamedMapping = new Map();
            for (let i = 0; i < renamedPairs.length; i += 2) {
              if (i + 1 < renamedPairs.length) {
                const oldPath = renamedPairs[i];
                const newPath = renamedPairs[i + 1];
                renamedMapping.set(oldPath, newPath);
                renamedFiles.push({ old: oldPath, new: newPath });
              }
            }
            
            // Filter out renamed files from added and deleted
            const addedFiltered = added.filter(f => !Array.from(renamedMapping.values()).includes(f));
            const deletedFiltered = deleted.filter(f => !Array.from(renamedMapping.keys()).includes(f));
            
            const previewUrl = (process.env.PREVIEW_URL || '').replace(/\/$/, '');
            const commentId = process.env.COMMENT_ID;
            const prNumber = process.env.PR_NUMBER;
            
            if (!commentId || !prNumber) {
              core.error('Missing comment ID or PR number');
              return;
            }
            
            // Load docs.json to map files to URLs
            let navigation = {};
            try {
              const docsJsonPath = 'docs.json';
              if (fs.existsSync(docsJsonPath)) {
                const docsJson = JSON.parse(fs.readFileSync(docsJsonPath, 'utf8'));
                
                // Build a map from file paths to URLs
                function processNavigation(items, basePath = '') {
                  for (const item of items || []) {
                    if (typeof item === 'string') {
                      // Simple string reference
                      navigation[item] = item;
                      navigation[item + '.mdx'] = item;
                      navigation[item + '.md'] = item;
                    } else if (typeof item === 'object') {
                      // Object with pages or group
                      if (item.page) {
                        navigation[item.page] = item.page;
                        navigation[item.page + '.mdx'] = item.page;
                        navigation[item.page + '.md'] = item.page;
                      }
                      if (item.pages) {
                        processNavigation(item.pages, basePath);
                      }
                      if (item.group && item.pages) {
                        processNavigation(item.pages, basePath);
                      }
                    }
                  }
                }
                
                // Process all navigation sections
                if (docsJson.navigation) {
                  processNavigation(docsJson.navigation);
                }
                if (docsJson.tabs && Array.isArray(docsJson.tabs)) {
                  for (const tab of docsJson.tabs) {
                    if (tab && tab.pages) {
                      processNavigation(tab.pages);
                    }
                  }
                }
                if (docsJson.anchors) {
                  processNavigation(docsJson.anchors);
                }
                
                core.info(`Loaded ${Object.keys(navigation).length} navigation entries from docs.json`);
              }
            } catch (e) {
              core.warning(`Could not load docs.json: ${e.message}`);
            }
            
            function mapFileToUrl(filePath) {
              // Remove leading slash if present
              let normalized = filePath.replace(/^\//, '');
              
              // Try direct match
              if (navigation[normalized]) {
                return navigation[normalized];
              }
              
              // Try without extension
              const withoutExt = normalized.replace(/\.(mdx?|jsx?)$/, '');
              if (navigation[withoutExt]) {
                return navigation[withoutExt];
              }
              
              // For files not in navigation, construct URL from path
              // Remove extension and return as URL path
              return '/' + withoutExt;
            }
            
            function titleFromPath(p) {
              let base = path.basename(p, path.extname(p));
              
              // Handle special icon naming pattern like "Mode=Dark assets/icons/Name=Agents"
              // Extract just the meaningful part (e.g., "Agents Dark")
              if (base.includes('Name=') || base.includes('Mode=')) {
                const nameMatch = base.match(/Name=([^,\s]+)/);
                const modeMatch = base.match(/Mode=([^,\s]+)/);
                
                if (nameMatch || modeMatch) {
                  const parts = [];
                  if (nameMatch) parts.push(nameMatch[1]);
                  if (modeMatch) parts.push(modeMatch[1]);
                  base = parts.join(' ');
                }
              }
              
              if (base === 'index') {
                const dir = path.dirname(p);
                const parent = path.basename(dir);
                return parent.replace(/[-_]+/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
              }
              return base.replace(/[-_]+/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
            }
            
            function buildRows(files, isDeleted = false) {
              const rows = [];
              
              for (const fp of files) {
                const isMdFile = /\.(mdx?|jsx?)$/.test(fp);
                const isAsset = /\.(png|jpe?g|gif|webp|svg|css|js|ico|txt|pdf|mp4|webm)$/i.test(fp);
                
                if (isMdFile) {
                  const url = mapFileToUrl(fp);
                  const title = titleFromPath(fp);
                  const href = (previewUrl && !isDeleted) ? previewUrl + url : '';
                  const titleCell = href ? `[${title}](${href})` : title;
                  const pathCell = `\`${fp}\``;
                  rows.push(`| ${titleCell} | ${pathCell} |`);
                } else if (isAsset) {
                  // Direct link to assets
                  const title = titleFromPath(fp);
                  const href = (previewUrl && !isDeleted) ? `${previewUrl}/${fp}` : '';
                  const titleCell = href ? `[${title}](${href})` : title;
                  const pathCell = `\`${fp}\``;
                  rows.push(`| ${titleCell} | ${pathCell} |`);
                } else {
                  // Other files (config, etc.)
                  const title = titleFromPath(fp);
                  const pathCell = `\`${fp}\``;
                  rows.push(`| ${title} | ${pathCell} |`);
                }
              }
              
              return rows;
            }
            
            function buildRenamedRows(renamedFiles) {
              const rows = [];
              
              for (const rename of renamedFiles) {
                const isMdFile = /\.(mdx?|jsx?)$/.test(rename.new);
                
                if (isMdFile) {
                  const url = mapFileToUrl(rename.new);
                  const title = titleFromPath(rename.new);
                  const href = previewUrl ? previewUrl + url : '';
                  const titleCell = href ? `[${title}](${href})` : title;
                  const pathCell = `\`${rename.old}\` ‚Üí \`${rename.new}\``;
                  rows.push(`| ${titleCell} | ${pathCell} |`);
                } else {
                  const title = titleFromPath(rename.new);
                  const pathCell = `\`${rename.old}\` ‚Üí \`${rename.new}\``;
                  rows.push(`| ${title} | ${pathCell} |`);
                }
              }
              
              return rows;
            }
            
            // Limit files to prevent comment from being too large
            const MAX_ROWS_PER_TABLE = 20;
            
            function limitFiles(files, max) {
              if (files.length <= max) {
                return { files: files.sort(), truncated: false, total: files.length };
              }
              return { 
                files: files.slice(0, max).sort(), 
                truncated: true, 
                total: files.length 
              };
            }
            
            const addedInfo = limitFiles(addedFiltered, MAX_ROWS_PER_TABLE);
            const modifiedInfo = limitFiles(modified, MAX_ROWS_PER_TABLE);
            const deletedInfo = limitFiles(deletedFiltered, MAX_ROWS_PER_TABLE);
            const renamedInfo = limitFiles(renamedFiles, MAX_ROWS_PER_TABLE);
            
            const addedRows = buildRows(addedInfo.files);
            const modifiedRows = buildRows(modifiedInfo.files);
            const deletedRows = buildRows(deletedInfo.files, true);
            const renamedRows = buildRenamedRows(renamedInfo.files);
            
            // Build comment body
            const header = `<!-- mintlify-preview-links -->\n<!-- preview-base: ${previewUrl || ''} -->\n**Mintlify PR Preview: Changed content**`;
            
            let body = header;
            
            if (previewUrl) {
              body += `\n\nüîó **Preview URL:** ${previewUrl}`;
            } else {
              body += '\n\n‚è≥ *Waiting for Mintlify deployment to complete...*';
            }
            
            function section(title, rows, info) {
              if (rows.length === 0) return '';
              
              let sectionTitle = title;
              if (info.truncated) {
                sectionTitle += ` (showing ${rows.length} of ${info.total} files)`;
              }
              
              return `\n\n### ${sectionTitle}\n\n| Title | Path |\n| --- | --- |\n${rows.join('\n')}`;
            }
            
            body += section('Renamed/Moved', renamedRows, renamedInfo);
            body += section('Added', addedRows, addedInfo);
            body += section('Modified', modifiedRows, modifiedInfo);
            body += section('Deleted', deletedRows, deletedInfo);
            
            if (addedRows.length === 0 && modifiedRows.length === 0 && 
                deletedRows.length === 0 && renamedRows.length === 0) {
              body += '\n\nNo documentation content changes detected.';
            }
            
            body += '\n\n<sub>This comment is automatically updated when changes are detected.</sub>';
            
            // Update the comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(commentId),
              body,
            });
            
            core.info(`Updated preview comment with ${addedFiltered.length + modified.length + deletedFiltered.length + renamedFiles.length} changed files`);
