---
title: Weave の問題のトラブルシューティング
description: thoughtful philosophy dispensing... Weave の利用中に遭遇する可能性がある一般的な問題の解決策とガイダンス。
---

このページでは、遭遇する可能性のある一般的な問題に対する解決策とガイダンスを提供します。このガイドは継続的に拡張されており、より幅広いシナリオに対応するため、今後もさらなるトラブルシューティングトピックが追加される予定です。

<Tip>
コミュニティに共有したい Weave のトラブルシューティングのアドバイスをお持ちですか？このガイドの下部にある **Edit this page** をクリックして、プルリクエストを送信することで直接貢献していただけます。
</Tip>

## トレース ページの読み込みが遅い

トレース ページの読み込みが遅い場合は、表示される行数を減らすことでロード時間を改善してください。デフォルト値は `50` です。UI から行数を減らすか、クエリパラメータを使用することができます。

### UI で調整する（推奨）

トレース ページの右下にある **Per page** コントロールを使用して、表示される行数を調整します。デフォルトの `50` に加えて、 `10` 、 `25` 、または `100` に設定することも可能です。

### クエリパラメータを使用する

手動でのアプローチを好む場合は、クエリ URL の `pageSize` クエリパラメータを、最大値の `100` 未満の値に変更してください。

## サーバーレスポンスのキャッシング

Weave は、繰り返しのクエリを実行したり、ネットワーク帯域幅が制限されている環境で作業したりする際のパフォーマンスを向上させるために、サーバーレスポンスのキャッシングを提供しています。現在はデフォルトで無効になっていますが、将来のリリースではこの振る舞いがデフォルトになる予定です。

### キャッシングを使用すべきタイミング

サーバーレスポンスのキャッシングは、特に以下のような場合に有益です：

- 同じクエリを頻繁に実行する場合
- ネットワーク帯域幅が限られている場合
- レイテンシの高い環境で作業している場合
- オフラインで開発しており、後で使用するためにレスポンスをキャッシュしたい場合

この機能は、データセットに対して繰り返しの 評価 を実行する際に特に便利です。これによって、 run 間のデータセットをキャッシュできるようになります。

### キャッシングを有効にする方法

キャッシングを有効にするには、以下の環境変数を設定します：

```bash
# サーバーレスポンスのキャッシングを有効にする
export WEAVE_USE_SERVER_CACHE=true

# キャッシュサイズの制限を設定（デフォルトは 1GB）
export WEAVE_SERVER_CACHE_SIZE_LIMIT=1000000000

# キャッシュディレクトリを設定（オプション、デフォルトは一時ディレクトリ）
export WEAVE_SERVER_CACHE_DIR=/path/to/cache
```

### キャッシングの振る舞い

技術的には、この機能はサーバーに対するべき等（idempotent）なリクエストをキャッシュします。具体的には、以下のリクエストをキャッシュします：

- `obj_read`
- `table_query`
- `table_query_stats`
- `refs_read_batch`
- `file_content_read`

### キャッシュサイズとストレージの詳細

キャッシュサイズは `WEAVE_SERVER_CACHE_SIZE_LIMIT` （バイト単位）で制御されます。実際に使用されるディスク容量は、以下の3つのコンポーネントで構成されます：

1. 固定 32KB のチェックサムファイル
2. 実行中のクライアントごとに最大約 4MB のライトアヘッドログ（WAL）ファイル（プログラム終了時に自動的に削除されます）
3. メインのデータベースファイル。最小 32KB、最大 `WEAVE_SERVER_CACHE_SIZE_LIMIT`

使用される総ディスク容量：

- 実行中 >= 32KB + 約 4MB + キャッシュサイズ
- 終了後 >= 32KB + キャッシュサイズ

例えば、5MB のキャッシュ制限を設定した場合：

- 実行中：最大約 9MB
- 終了後：最大約 5MB

## トレースデータが切り捨てられる

大きな トレース データが Weave UI で一部切り捨てられることがあります。この問題は、デフォルトの トレース 出力が生のカスタム Python オブジェクトであり、Weave がそのシリアライズ方法を認識できないために発生します。

大きな トレース データが切り捨てられないようにするには、すべての トレース データを返す文字列の 辞書 を定義してください。

```python lines
import weave

class MyObj:
    def __init__(self, x: int):
        self.x = x

    def __repr__(self):
        return f"MyObj(x={self.x})"

    def to_dict(self):
        return {"x": self.x}

@weave.op()
def make_my_obj():
    x = "s" * 10_000
    return MyObj(x)
```

## 評価 のクリーンアップに時間がかかる

大きな Datasets で 評価 を実行する際のパフォーマンスを向上させるために、以下の2つの メソッド を組み合わせて使用する必要があります。

### フラッシング

大きな Datasets で 評価 を実行すると、バックグラウンドスレッドでデータセットがアップロードされている間、プログラムの実行前に長い時間がかかることがあります。これは通常、バックグラウンドのクリーンアップが完了する前にメインスレッドの実行が終了した場合に発生します。 `client.flush()` を呼び出すと、すべてのバックグラウンドタスクがメインスレッドで強制的に処理され、メインスレッドの実行中に並列プロセッシングが行われるようになります。これにより、サーバーへのデータアップロードが完了する前にユーザー コード が終了する場合のパフォーマンスが向上します。

例：

```python lines
client = weave.init("fast-upload")

# ... 評価のセットアップ
result = evaluation.Evaluate(dataset_id="my_dataset_id")

client.flush()
```

### クライアントの並列性の向上

クライアントの並列性は 環境 に基づいて自動的に決定されますが、以下の環境変数を使用して手動で設定することも可能です：

- `WEAVE_CLIENT_PARALLELISM`: 並列 プロセッシング に使用可能なスレッド数。この数値を増やすと、並列 プロセッシング に使用できるスレッドが増え、データセットのアップロードなどのバックグラウンドタスクのパフォーマンスが向上する可能性があります。

これは `weave.init()` の `settings` 引数 を使用してプログラムから設定することもできます：

```python lines
client = weave.init("fast-upload", settings={"client_parallelism": 100})
```

## OS エラー

### `[Errno 24]: Too many open files`

このエラーは、開いているファイルの数がオペレーティングシステムによって設定された制限を超えたときに発生します。Weave では、大きな画像 Datasets を扱っている場合にこれが発生することがあります。Weave は画像 プロセッシング に `PIL` を使用しており、プログラムの実行期間中、ファイル記述子が開いたままになります。

この問題を解決するには、 `ulimit` を使用して、システムが開くことができるファイルの制限を `65,536` に増やしてください：

```bash
ulimit -n 65536
```