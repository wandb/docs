---
title: "W&B Models와 함께 Weave 사용하기"
description: "W&B Weave를 사용해 Weave와 W&B Models를 함께 사용하는 방법을 알아보세요"
---

<Note>
이 노트북은 대화형으로 구성되어 있습니다. 로컬에서 실행하거나 아래 링크를 사용할 수 있습니다:
- [Google Colab에서 열기](https://colab.research.google.com/github/wandb/docs/blob/main/weave/cookbooks/source/Models_and_Weave_Integration_Demo.ipynb)
- [GitHub에서 소스 보기](https://github.com/wandb/docs/blob/main/weave/cookbooks/source/Models_and_Weave_Integration_Demo.ipynb)
</Note>

<div id="prerequisites">
  ## 사전 준비 사항
</div>

먼저 필요한 라이브러리를 설치하고 API 키를 설정한 뒤, W&amp;B에 로그인하고 새 W&amp;B 프로젝트를 생성합니다.

1. `pip`을 사용하여 `weave`, `pandas`, `unsloth`, `wandb`, `litellm`, `pydantic`, `torch`, `faiss-gpu`를 설치합니다.

```python lines
%%capture
!pip install weave wandb pandas pydantic litellm faiss-gpu
python
%%capture
!pip install unsloth
# 최신 nightly Unsloth도 설치하세요!
!pip uninstall unsloth -y && pip install --upgrade --no-cache-dir "unsloth[colab-new] @ git+https://github.com/unslothai/unsloth.git"
```

2. 실행 환경에서 필요한 API 키를 추가합니다.

```python lines
import os

from google.colab import userdata

os.environ["WANDB_API_KEY"] = userdata.get("WANDB_API_KEY")  # W&B Models and Weave
os.environ["OPENAI_API_KEY"] = userdata.get(
    "OPENAI_API_KEY"
)  # OpenAI - 검색 임베딩용
os.environ["GEMINI_API_KEY"] = userdata.get(
    "GEMINI_API_KEY"
)  # Gemini - 기본 채팅 모델용
```

3. W&amp;B에 로그인한 다음 새 프로젝트를 생성합니다.

```python lines
import pandas as pd
import wandb

import weave

wandb.login()

PROJECT = "weave-cookboook-demo"
ENTITY = "wandb-smle"

weave.init(ENTITY + "/" + PROJECT)
```


<div id="download-chatmodel-from-models-registry-and-implement-unslothlorachatmodel">
  ##  Models Registry에서 `ChatModel`을 다운로드하고 `UnslothLoRAChatModel`을 구현하기
</div>

이 시나리오에서는 Llama-3.2 모델이 이미 모델 팀에서 성능 최적화를 위해 `unsloth` 라이브러리를 사용해 파인튜닝되었고, [W&B Models Registry에서 사용할 수 있습니다](https://wandb.ai/wandb-smle/weave-cookboook-demo/weave/object-versions?filter=%7B%22objectName%22%3A%22RagModel%22%7D&peekPath=%2Fwandb-smle%2Fweave-rag-experiments%2Fobjects%2FChatModelRag%2Fversions%2F2mhdPb667uoFlXStXtZ0MuYoxPaiAXj3KyLS1kYRi84%3F%26). 이 단계에서는 Registry에서 파인튜닝된 [`ChatModel`](https://wandb.ai/wandb-smle/weave-cookboook-demo/weave/object-versions?filter=%7B%22objectName%22%3A%22RagModel%22%7D&peekPath=%2Fwandb-smle%2Fweave-rag-experiments%2Fobjects%2FChatModelRag%2Fversions%2F2mhdPb667uoFlXStXtZ0MuYoxPaiAXj3KyLS1kYRi84%3F%26)을 가져와 이를 `weave.Model`로 변환해 [`RagModel`](https://wandb.ai/wandb-smle/weave-cookboook-demo/weave/object-versions?filter=%7B%22objectName%22%3A%22RagModel%22%7D&peekPath=%2Fwandb-smle%2Fweave-cookboook-demo%2Fobjects%2FRagModel%2Fversions%2FcqRaGKcxutBWXyM0fCGTR1Yk2mISLsNari4wlGTwERo%3F%26)과 호환되도록 만듭니다. 

<Note>
아래에서 참조하는 `RagModel`은 완전한 RAG 애플리케이션으로 볼 수 있는 최상위 `weave.Model`입니다. 이 모델은 `ChatModel`, 벡터 데이터베이스, 프롬프트를 포함합니다. `ChatModel` 역시 `weave.Model`로, W&B Registry에서 아티팩트를 다운로드하는 코드를 포함하고 있습니다. `ChatModel`은 `RagModel`의 일부로서 다양한 종류의 다른 LLM 채팅 모델을 지원하도록 모듈식으로 교체할 수 있습니다. 자세한 내용은 [Weave에서 모델을 확인](https://wandb.ai/wandb-smle/weave-cookboook-demo/weave/evaluations?peekPath=%2Fwandb-smle%2Fweave-cookboook-demo%2Fobjects%2FRagModel%2Fversions%2Fx7MzcgHDrGXYHHDQ9BA8N89qDwcGkdSdpxH30ubm8ZM%3F%26)하세요.
</Note>

`ChatModel`을 로드하기 위해 어댑터가 포함된 `unsloth.FastLanguageModel` 또는 `peft.AutoPeftModelForCausalLM`을 사용해 애플리케이션에 효율적으로 인테그레이션할 수 있습니다. Registry에서 모델을 다운로드한 후 `model_post_init` 메서드를 사용해 초기화 및 예측 로직을 설정할 수 있습니다. 이 단계에 필요한 코드는 Registry의 **Use** 탭에 있으며, 구현에 그대로 복사해 사용할 수 있습니다.

아래 코드는 W&B Models Registry에서 가져온 파인튜닝된 Llama-3.2 모델을 관리, 초기화, 사용하기 위해 `UnslothLoRAChatModel` 클래스를 정의합니다. `UnslothLoRAChatModel`은 최적화된 추론을 위해 `unsloth.FastLanguageModel`을 사용합니다. `model_post_init` 메서드는 모델 다운로드 및 설정을 처리하고, `predict` 메서드는 사용자 질의를 처리해 응답을 생성합니다. 자신의 사용 사례에 맞게 코드를 수정하려면, 파인튜닝된 모델에 대한 올바른 Registry 경로로 `MODEL_REG_URL`을 업데이트하고, 하드웨어나 요구 사항에 따라 `max_seq_length` 또는 `dtype`과 같은 파라미터를 조정하십시오.

```python lines
from typing import Any

from pydantic import PrivateAttr
from unsloth import FastLanguageModel

import weave

class UnslothLoRAChatModel(weave.Model):
    """
    모델 이름뿐만 아니라 더 많은 파라미터를 저장하고 버전 관리할 수 있도록 추가 ChatModel 클래스를 정의합니다.
    특히, 특정 파라미터로 인해 파인튜닝(로컬 또는 aaS)을 고려하는 경우에 유용합니다.
    """

    chat_model: str
    cm_temperature: float
    cm_max_new_tokens: int
    cm_quantize: bool
    inference_batch_size: int
    dtype: Any
    device: str
    _model: Any = PrivateAttr()
    _tokenizer: Any = PrivateAttr()

    def model_post_init(self, __context):
        # 레지스트리의 "Use" 탭에서 이 내용을 그대로 붙여넣을 수 있습니다
        run = wandb.init(project=PROJECT, job_type="model_download")
        artifact = run.use_artifact(f"{self.chat_model}")
        model_path = artifact.download()

        # unsloth 버전 (네이티브 2배 빠른 추론 활성화)
        self._model, self._tokenizer = FastLanguageModel.from_pretrained(
            model_name=model_path,
            max_seq_length=self.cm_max_new_tokens,
            dtype=self.dtype,
            load_in_4bit=self.cm_quantize,
        )
        FastLanguageModel.for_inference(self._model)

    @weave.op()
    async def predict(self, query: list[str]) -> dict:
        # add_generation_prompt = true - 생성 시 반드시 추가해야 합니다
        input_ids = self._tokenizer.apply_chat_template(
            query,
            tokenize=True,
            add_generation_prompt=True,
            return_tensors="pt",
        ).to("cuda")

        output_ids = self._model.generate(
            input_ids=input_ids,
            max_new_tokens=64,
            use_cache=True,
            temperature=1.5,
            min_p=0.1,
        )

        decoded_outputs = self._tokenizer.batch_decode(
            output_ids[0][input_ids.shape[1] :], skip_special_tokens=True
        )

        return "".join(decoded_outputs).strip()
python
MODEL_REG_URL = "wandb32/wandb-registry-RAG Chat Models/Finetuned Llama-3.2:v3"

max_seq_length = 2048  # 원하는 값을 선택하세요! 내부적으로 RoPE Scaling을 자동 지원합니다!
dtype = (
    None  # 자동 감지는 None. Tesla T4, V100은 Float16, Ampere 이상은 Bfloat16
)
load_in_4bit = True  # 메모리 사용량 절감을 위해 4bit 양자화 사용. False로 설정 가능.

new_chat_model = UnslothLoRAChatModel(
    name="UnslothLoRAChatModelRag",
    chat_model=MODEL_REG_URL,
    cm_temperature=1.0,
    cm_max_new_tokens=max_seq_length,
    cm_quantize=load_in_4bit,
    inference_batch_size=max_seq_length,
    dtype=dtype,
    device="auto",
)
python
await new_chat_model.predict(
    [{"role": "user", "content": "What is the capital of Germany?"}]
)
```


<div id="integrate-the-new-chatmodel-version-into-ragmodel">
  ## 새로운 `ChatModel` 버전을 `RagModel`에 통합하기
</div>

파인튜닝된 챗 모델을 기반으로 RAG 애플리케이션을 구축하면, 전체 파이프라인을 다시 만들 필요 없이 맞춤형 컴포넌트를 활용해 대화형 AI를 개선할 수 있습니다. 이 단계에서는 Weave 프로젝트에서 기존 `RagModel`을 가져와, 그 `ChatModel`이 새로 파인튜닝된 모델을 사용하도록 업데이트합니다. 이렇게 매끄럽게 교체하면 벡터 데이터베이스(VDB)나 프롬프트 같은 다른 컴포넌트는 그대로 유지되며, 애플리케이션의 전체 구조를 보존하면서도 성능을 향상시킬 수 있습니다.

아래 코드는 Weave 프로젝트의 참조를 사용해 `RagModel` 객체를 가져옵니다. 그런 다음 `RagModel`의 `chat_model` 속성을 이전 단계에서 생성한 새로운 `UnslothLoRAChatModel` 인스턴스를 사용하도록 업데이트합니다. 이후 업데이트된 `RagModel`을 게시하여 새 버전을 생성합니다. 마지막으로, 업데이트된 `RagModel`을 사용해 샘플 예측 쿼리를 실행하여 새로운 챗 모델이 실제로 사용되고 있음을 검증합니다.

```python lines
RagModel = weave.ref(
    "weave://wandb-smle/weave-cookboook-demo/object/RagModel:cqRaGKcxutBWXyM0fCGTR1Yk2mISLsNari4wlGTwERo"
).get()
python
RagModel.chat_model.chat_model
python
await RagModel.predict("When was the first conference on climate change?")
python
# MAGIC: chat_model을 교체하고 새 버전을 게시합니다 (다른 RAG 컴포넌트는 신경 쓸 필요 없음)
RagModel.chat_model = new_chat_model
python
RagModel.chat_model.chat_model
python
# 먼저 새 버전을 게시하여 예측 시 새 버전을 참조하도록 합니다
PUB_REFERENCE = weave.publish(RagModel, "RagModel")
python
await RagModel.predict("When was the first conference on climate change?")
```


<div id="run-a-weaveevaluation">
  ## `weave.Evaluation` 실행하기
</div>

다음 단계에서는 기존 `weave.Evaluation`을 사용해 업데이트된 `RagModel`의 성능을 평가합니다. 이 과정은 새로 파인튜닝된 챗 모델이 RAG 애플리케이션 내에서 예상대로 동작하는지 확인하기 위한 것입니다. Models 팀과 Apps 팀 간 인테그레이션을 간소화하고 협업을 활성화하기 위해, 모델의 W&amp;B run과 Weave Workspace 모두에 대한 평가 결과를 로깅합니다.

Models에서:

* 평가 요약은 파인튜닝된 챗 모델을 다운로드하는 데 사용된 W&amp;B run에 기록됩니다. 여기에는 분석을 위해 [Workspace 뷰](https://wandb.ai/wandb-smle/weave-cookboook-demo/workspace?nw=eglm8z7o9)에 표시되는 요약 메트릭과 그래프가 포함됩니다.
* 평가 트레이스 ID는 run의 설정에 추가되어 Models 팀이 Weave 페이지로 직접 이동해 더 쉽게 추적할 수 있습니다.

Weave에서:

* `ChatModel`의 아티팩트 또는 Registry 링크는 `RagModel`의 입력으로 저장됩니다.
* W&amp;B run ID는 더 나은 컨텍스트를 위해 평가 트레이스의 추가 열로 저장됩니다.

아래 코드는 평가 객체를 가져오고, 업데이트된 `RagModel`을 사용해 평가를 실행한 뒤, 결과를 W&amp;B와 Weave에 모두 로깅하는 방법을 보여줍니다. 평가 참조(`WEAVE_EVAL`)가 프로젝트 설정과 일치하는지 확인하십시오.

```python lines
# MAGIC: 평가 데이터셋과 스코어러로 평가를 간단히 가져와 사용할 수 있습니다
WEAVE_EVAL = "weave://wandb-smle/weave-cookboook-demo/object/climate_rag_eval:ntRX6qn3Tx6w3UEVZXdhIh1BWGh7uXcQpOQnIuvnSgo"
climate_rag_eval = weave.ref(WEAVE_EVAL).get()
python
with weave.attributes({"wandb-run-id": wandb.run.id}):
    # .call 속성을 사용하여 결과와 call을 모두 가져와 평가 트레이스를 Models에 저장합니다
    summary, call = await climate_rag_eval.evaluate.call(climate_rag_eval, RagModel)
python
# Models에 로그 기록
wandb.run.log(pd.json_normalize(summary, sep="/").to_dict(orient="records")[0])
wandb.run.config.update(
    {"weave_url": f"https://wandb.ai/wandb-smle/weave-cookboook-demo/r/call/{call.id}"}
)
wandb.run.finish()
```


<div id="save-the-new-rag-model-to-the-registry">
  ## 새 RAG 모델을 Registry에 저장하기
</div>

업데이트된 `RagModel`을 향후 Models 팀과 Apps 팀 모두에서 사용할 수 있도록, 이 모델을 참조용 아티팩트로 W&amp;B Models Registry에 푸시합니다.

아래 코드는 업데이트된 `RagModel`에 대한 `weave` 객체 버전과 이름을 가져와 이를 사용해 참조 링크를 만듭니다. 그런 다음 모델의 Weave URL을 포함하는 메타데이터와 함께 새로운 아티팩트를 W&amp;B에 생성합니다. 이 아티팩트는 W&amp;B Registry에 로그되며 지정된 레지스트리 경로에 연결됩니다.

코드를 실행하기 전에 `ENTITY`와 `PROJECT` 변수가 사용하는 W&amp;B 설정과 일치하는지, 그리고 대상 레지스트리 경로가 올바르게 지정되어 있는지 확인하세요. 이 과정은 새로운 `RagModel`을 손쉬운 협업과 재사용을 위해 W&amp;B 생태계에 게시하여 워크플로를 마무리합니다.

```python lines
MODELS_OBJECT_VERSION = PUB_REFERENCE.digest  # weave 오브젝트 버전
MODELS_OBJECT_NAME = PUB_REFERENCE.name  # weave 오브젝트 이름
python
models_url = f"https://wandb.ai/{ENTITY}/{PROJECT}/weave/objects/{MODELS_OBJECT_NAME}/versions/{MODELS_OBJECT_VERSION}"
models_link = (
    f"weave://{ENTITY}/{PROJECT}/object/{MODELS_OBJECT_NAME}:{MODELS_OBJECT_VERSION}"
)

with wandb.init(project=PROJECT, entity=ENTITY) as run:
    # 새 아티팩트 생성
    artifact_model = wandb.Artifact(
        name="RagModel",
        type="model",
        description="Models Link from RagModel in Weave",
        metadata={"url": models_url},
    )
    artifact_model.add_reference(models_link, name="model", checksum=False)

    # 새 아티팩트 로깅
    run.log_artifact(artifact_model, aliases=[MODELS_OBJECT_VERSION])

    # 레지스트리에 연결
    run.link_artifact(
        artifact_model, target_path="wandb32/wandb-registry-RAG Models/RAG Model"
    )
```
