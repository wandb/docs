---
title: "LangChain"
description: "Weave를 사용해 LangChain Python 라이브러리를 통해 이루어지는 모든 호출을 추적하고 로깅하기"
---

<a target="_blank" href="https://colab.research.google.com/github/wandb/examples/blob/master/weave/docs/quickstart_langchain.ipynb" aria-label="Open in Google Colab">
  <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab" />
</a>

Weave는 [LangChain Python 라이브러리](https://github.com/langchain-ai/langchain)를 통해 이루어지는 모든 호출을 손쉽게 추적하고 로깅할 수 있도록 설계되었습니다.

LLM과 작업할 때 디버깅은 피할 수 없습니다. 모델 호출이 실패하거나, 출력 형식이 맞지 않거나, 중첩된 모델 호출로 인해 혼란이 생기는 등, 문제 지점을 정확히 찾기 어려울 수 있습니다. LangChain 애플리케이션은 여러 단계와 LLM 호출로 구성되는 경우가 많기 때문에, 체인과 에이전트의 내부 동작을 이해하는 것이 매우 중요합니다.

Weave는 [LangChain](https://docs.langchain.com/oss/python/langchain/overview) 애플리케이션에 대한 트레이스를 자동으로 캡처하여 이 과정을 단순화합니다. 이를 통해 애플리케이션의 성능을 모니터링하고 분석할 수 있으며, LLM 워크플로를 더 쉽게 디버깅하고 최적화할 수 있습니다.

<div id="getting-started">
  ## 시작하기
</div>

시작하려면 스크립트의 맨 앞에서 `weave.init()`을 호출하면 됩니다. `weave.init()`의 인수는 트레이스를 정리하는 데 도움이 되는 프로젝트 이름입니다.

```python lines {6}
import weave
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 프로젝트 이름으로 Weave 초기화
weave.init("langchain_demo")

llm = ChatOpenAI()
prompt = PromptTemplate.from_template("1 + {number} = ")

llm_chain = prompt | llm

output = llm_chain.invoke({"number": 2})

print(output)
```

<div id="tracking-call-metadata">
  ## 호출 메타데이터 추적
</div>

LangChain 호출의 메타데이터를 추적하려면 [`weave.attributes`](/ko/weave/reference/python-sdk#function-attributes) 컨텍스트 매니저를 사용할 수 있습니다. 이 컨텍스트 매니저를 사용하면 체인이나 단일 요청과 같은 특정 코드 블록에 대해 사용자 지정 메타데이터를 설정할 수 있습니다.

```python lines {6,13}
import weave
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 프로젝트 이름으로 Weave 초기화
weave.init("langchain_demo")

llm = ChatOpenAI()
prompt = PromptTemplate.from_template("1 + {number} = ")

llm_chain = prompt | llm

with weave.attributes({"my_awesome_attribute": "value"}):
    output = llm_chain.invoke()

print(output)
```

Weave는 LangChain 호출 트레이스의 메타데이터를 자동으로 추적합니다. 아래와 같이 Weave 웹 인터페이스에서 메타데이터를 확인할 수 있습니다.

[![langchain\_attributes.png](/weave/guides/integrations/imgs/langchain_attributes.png)](https://wandb.ai/parambharat/langchain_demo/weave/traces?cols=%7B%22attributes.weave.client_version%22%3Afalse%2C%22attributes.weave.os_name%22%3Afalse%2C%22attributes.weave.os_release%22%3Afalse%2C%22attributes.weave.os_version%22%3Afalse%2C%22attributes.weave.source%22%3Afalse%2C%22attributes.weave.sys_version%22%3Afalse%7D)

<div id="traces">
  ## 트레이스
</div>

LLM 애플리케이션의 트레이스를 중앙 데이터베이스에 저장하는 것은 개발 단계와 프로덕션 환경 모두에서 매우 중요합니다. 이러한 트레이스는 유용한 데이터셋을 제공하여 애플리케이션을 디버깅하고 개선하는 데 필수적입니다.

Weave는 LangChain 애플리케이션의 트레이스를 자동으로 캡처합니다. 프롬프트 템플릿, 체인, LLM 호출, 도구, 에이전트 단계 등을 포함해 LangChain 라이브러리를 통해 이루어지는 모든 호출을 추적하고 로깅합니다. Weave 웹 인터페이스에서 트레이스를 확인할 수 있습니다.

[![langchain\_trace.png](/weave/guides/integrations/imgs/langchain_trace.png)](https://wandb.ai/parambharat/langchain_demo/weave/calls)

<div id="manually-tracing-calls">
  ## 호출을 수동으로 추적하기
</div>

자동 추적 외에도 `WeaveTracer` 콜백이나 `weave_tracing_enabled` 컨텍스트 매니저를 사용해 호출을 수동으로 추적할 수 있습니다. 이 방법들은 LangChain 애플리케이션의 개별 부분에서 요청 콜백을 사용하는 것과 비슷한 방식입니다.

**Note:** Weave는 기본적으로 LangChain Runnables를 추적하며, 이는 `weave.init()`을 호출할 때 활성화됩니다. `weave.init()`을 호출하기 전에 환경 변수 `WEAVE_TRACE_LANGCHAIN`을 `"false"`로 설정하여 이 동작을 비활성화할 수 있습니다. 이렇게 하면 애플리케이션에서 특정 체인이나 개별 요청의 추적 동작을 제어할 수 있습니다.

<div id="using-weavetracer">
  ### `WeaveTracer` 사용하기
</div>

개별 LangChain 컴포넌트에 `WeaveTracer` 콜백을 전달하여 특정 요청만 추적할 수 있습니다.

```python lines {11,13,15,22}
import os

os.environ["WEAVE_TRACE_LANGCHAIN"] = "false" # <- 전역 추적을 명시적으로 비활성화합니다.

from weave.integrations.langchain import WeaveTracer
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
import weave

# 프로젝트 이름으로 Weave를 초기화합니다
weave.init("langchain_demo")  # <-- 환경 변수가 명시적으로 `false`로 설정되어 있으므로 여기서는 추적을 활성화하지 않습니다

weave_tracer = WeaveTracer()

config = {"callbacks": [weave_tracer]}

llm = ChatOpenAI()
prompt = PromptTemplate.from_template("1 + {number} = ")

llm_chain = prompt | llm

output = llm_chain.invoke({"number": 2}, config=config) # <-- 이 체인 호출에 대해서만 추적을 활성화합니다.

llm_chain.invoke({"number": 4})  # <-- langchain 호출에 대해서는 추적이 활성화되지 않지만 openai 호출은 계속 추적됩니다
```

<div id="using-weave_tracing_enabled-context-manager">
  ### `weave_tracing_enabled` 컨텍스트 매니저 사용
</div>

또 다른 방법으로, `weave_tracing_enabled` 컨텍스트 매니저를 사용하여 특정 코드 블록에만 트레이싱을 활성화할 수 있습니다.

```python lines {11,18}
import os

os.environ["WEAVE_TRACE_LANGCHAIN"] = "false" # <- 전역 추적을 명시적으로 비활성화합니다.

from weave.integrations.langchain import weave_tracing_enabled
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
import weave

# 프로젝트 이름으로 Weave를 초기화합니다
weave.init("langchain_demo")  # <-- 환경 변수가 명시적으로 `false`로 설정되어 있으므로 여기서는 추적을 활성화하지 않습니다

llm = ChatOpenAI()
prompt = PromptTemplate.from_template("1 + {number} = ")

llm_chain = prompt | llm

with weave_tracing_enabled():  # <-- 이 체인 호출에 대해서만 추적을 활성화합니다.
    output = llm_chain.invoke({"number": 2})


llm_chain.invoke({"number": 4})  # <-- langchain 호출에 대해서는 추적이 활성화되지 않지만 openai 호출은 계속 추적됩니다
```

<div id="configuration">
  ## 설정
</div>

`weave.init`을 호출하면 환경 변수 `WEAVE_TRACE_LANGCHAIN`을 `"true"`로 설정하여 트레이싱이 활성화됩니다. 이렇게 하면 Weave가 LangChain 애플리케이션의 트레이스를 자동으로 수집합니다. 이 동작을 비활성화하려면 환경 변수를 `"false"`로 설정하십시오.

<div id="relation-to-langchain-callbacks">
  ## LangChain 콜백과의 관계
</div>

<div id="auto-logging">
  ### 자동 로깅
</div>

`weave.init()`이 제공하는 자동 로깅 기능은 LangChain 애플리케이션의 모든 컴포넌트에 생성자 콜백을 전달하는 것과 유사합니다. 이는 프롬프트 템플릿, 체인, LLM 호출, 도구, 에이전트 스텝 등을 포함한 모든 상호작용이 애플리케이션 전체에서 전역적으로 추적된다는 의미입니다.

<div id="manual-logging">
  ### 수동 로깅
</div>

수동 로깅 메서드(`WeaveTracer` 및 `weave_tracing_enabled`)는 LangChain 애플리케이션의 개별 부분에서 요청 콜백을 사용하는 것과 유사합니다. 이 메서드들은 애플리케이션의 어떤 부분을 트레이싱할지 더 세밀하게 제어할 수 있도록 해 줍니다.

* **Constructor 콜백:** 전체 체인 또는 컴포넌트에 적용되어, 모든 상호작용을 일관되게 로깅합니다.
* **Request 콜백:** 특정 요청에만 적용되어, 특정 호출에 대한 상세한 트레이싱이 가능합니다.

Weave를 LangChain과 통합하면 LLM 애플리케이션에서 포괄적인 로깅과 모니터링을 수행할 수 있으므로, 디버깅과 성능 최적화를 더 쉽게 할 수 있습니다.

자세한 내용은 [LangChain 문서](https://python.langchain.com/v0.2/docs/how_to/debugging/#tracing)를 참고하십시오.

<div id="models-and-evaluations">
  ## Models 및 평가
</div>

프롬프트, 모델 설정, 추론 파라미터처럼 여러 구성 요소가 얽혀 있어 다양한 사용 사례에 맞게 애플리케이션에서 LLM을 구성하고 평가하는 일은 어렵습니다. [`weave.Model`](/ko/weave/guides/core-types/models)을 사용하면 시스템 프롬프트나 사용하는 모델과 같은 실험 세부 정보를 기록하고 정리할 수 있어, 서로 다른 반복 결과를 더 쉽게 비교할 수 있습니다.

다음 예시는 LangChain 체인을 `WeaveModel`로 래핑하는 방법을 보여 줍니다:

```python lines {10,12,16}
import json
import asyncio

import weave

from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 프로젝트 이름으로 Weave를 초기화합니다
weave.init("langchain_demo")

class ExtractFruitsModel(weave.Model):
    model_name: str
    prompt_template: str

    @weave.op()
    async def predict(self, sentence: str) -> dict:
        llm = ChatOpenAI(model=self.model_name, temperature=0.0)
        prompt = PromptTemplate.from_template(self.prompt_template)

        llm_chain = prompt | llm
        response = llm_chain.invoke({"sentence": sentence})
        result = response.content

        if result is None:
            raise ValueError("No response from model")
        parsed = json.loads(result)
        return parsed

model = ExtractFruitsModel(
    model_name="gpt-3.5-turbo-1106",
    prompt_template='Extract fields ("fruit": <str>, "color": <str>, "flavor": <str>) from the following text, as json: {sentence}',
)
sentence = "There are many fruits that were found on the recently discovered planet Goocrux. There are neoskizzles that grow there, which are purple and taste like candy."

prediction = asyncio.run(model.predict(sentence))

# Jupyter Notebook에서 실행하는 경우:
# prediction = await model.predict(sentence)

print(prediction)
```

이 코드는 Weave UI에서 시각화할 수 있는 모델을 만듭니다:

[![langchain\_model.png](/weave/guides/integrations/imgs/langchain_model.png)](https://wandb.ai/parambharat/langchain_demo/weave/object-versions?filter=%7B%22baseObjectClass%22%3A%22Model%22%7D\&peekPath=%2Fparambharat%2Flangchain_demo%2Fobjects%2FExtractFruitsModel%2Fversions%2FBeoL6WuCH8wgjy6HfmuBMyKzArETg1oAFpYaXZSq1hw%3F%26)

또한 Weave Models를 `serve` 및 [`Evaluations`](/ko/weave/guides/core-types/evaluations)와 함께 사용할 수도 있습니다.

<div id="evaluations">
  ### 평가
</div>

평가는 모델의 성능을 측정하는 데 도움이 됩니다. [`weave.Evaluation`](/ko/weave/guides/core-types/evaluations) 클래스를 사용하면 모델이 특정 작업이나 데이터셋에서 얼마나 잘 동작하는지 기록할 수 있어, 서로 다른 모델과 애플리케이션의 여러 버전을 더 쉽게 비교할 수 있습니다. 다음 예시는 우리가 생성한 모델을 어떻게 평가하는지 보여줍니다.

```python lines

from weave.scorers import MultiTaskBinaryClassificationF1

sentences = [
    "There are many fruits that were found on the recently discovered planet Goocrux. There are neoskizzles that grow there, which are purple and taste like candy.",
    "Pounits are a bright green color and are more savory than sweet.",
    "Finally, there are fruits called glowls, which have a very sour and bitter taste which is acidic and caustic, and a pale orange tinge to them.",
]
labels = [
    {"fruit": "neoskizzles", "color": "purple", "flavor": "candy"},
    {"fruit": "pounits", "color": "bright green", "flavor": "savory"},
    {"fruit": "glowls", "color": "pale orange", "flavor": "sour and bitter"},
]
examples = [
    {"id": "0", "sentence": sentences[0], "target": labels[0]},
    {"id": "1", "sentence": sentences[1], "target": labels[1]},
    {"id": "2", "sentence": sentences[2], "target": labels[2]},
]

@weave.op()
def fruit_name_score(target: dict, output: dict) -> dict:
    return {"correct": target["fruit"] == output["fruit"]}


evaluation = weave.Evaluation(
    dataset=examples,
    scorers=[
        MultiTaskBinaryClassificationF1(class_names=["fruit", "color", "flavor"]),
        fruit_name_score,
    ],
)
scores = asyncio.run(evaluation.evaluate(model)))
# Jupyter Notebook에서 실행하는 경우:
# scores = await evaluation.evaluate(model)

print(scores)
```

이 코드는 Weave UI에서 시각화할 수 있는 평가 트레이스를 생성합니다:

[![langchain\_evaluation.png](/weave/guides/integrations/imgs/langchain_eval.png)](https://wandb.ai/parambharat/langchain_demo/weave/calls?filter=%7B%22traceRootsOnly%22%3Atrue%7D\&peekPath=%2Fparambharat%2Flangchain_demo%2Fcalls%2F44c3f26c-d9d3-423e-b434-651ea5174be3)

Weave를 Langchain과 인테그레이션하면 LLM 애플리케이션을 포괄적으로 로깅하고 모니터링할 수 있어, 디버깅과 성능 최적화를 더 쉽게 수행할 수 있습니다.

<div id="known-issues">
  ## 알려진 이슈
</div>

* **비동기 호출 트레이싱** - Langchain의 `AsyncCallbackManager` 구현 버그로 인해 비동기 호출이 올바른 순서로 트레이싱되지 않는 문제가 있습니다. 이 문제를 해결하기 위한 [PR](https://github.com/langchain-ai/langchain/pull/23909)을 제출했습니다. 따라서 Langchain Runnables에서 `ainvoke`, `astream`, `abatch` 메서드를 사용할 때 트레이스에 기록되는 호출 순서가 정확하지 않을 수 있습니다.