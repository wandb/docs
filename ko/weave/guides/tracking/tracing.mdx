---
title: Tracing 기초
description: Weave tracing을 사용하여 AI 애플리케이션의 실행을 추적하고 모니터링하세요.
---

<Frame>
![Weave Calls Screenshot](/images/screenshots/calls_macro.png)
</Frame>

<Frame>
![Weave Calls Screenshot](/images/screenshots/basic_call.png)
</Frame>

<Frame>
![Weave Calls Screenshot](/images/screenshots/calls_filter.png)
</Frame>


Calls는 Weave 의 핵심 빌드 블록입니다. 이는 다음을 포함한 단일 함수 실행을 나타냅니다:
- Inputs (인수)
- Outputs (반환값) 
- 메타데이터 (기간, 예외, LLM 사용량 등)

Calls는 [OpenTelemetry](https://opentelemetry.io) 데이터 모델의 span과 유사합니다. Call은 다음이 가능합니다:
- Trace에 속함 (동일한 실행 컨텍스트 내의 calls 집합)
- 부모 및 자식 Calls를 가짐 (트리 구조 형성)


## Creating Calls

Weave 에서 Calls를 생성하는 세 가지 주요 방법이 있습니다:

### 1. LLM 라이브러리의 자동 추적

<Tabs>
  <Tab title="Python">
    Weave 는 `openai`, `anthropic`, `cohere`, `mistral`과 같은 [일반적인 LLM 라이브러리에 대한 호출](/weave/guides/integrations)을 자동으로 추적합니다. 프로그램 시작 시 [`weave.init('project_name')`](/weave/reference/python-sdk#function-init)을 호출하기만 하면 됩니다:

    <Tip>
    [`weave.init`의 `autopatch_settings` 인수를 사용하여](#configure-autopatching) Weave 의 기본 추적 동작을 제어할 수 있습니다.
    </Tip>

    ```python lines
    import weave

    from openai import OpenAI
    client = OpenAI()

    # Weave Tracing 초기화
    weave.init('intro-example')

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {
                "role": "user",
                "content": "How are you?"
            }
        ],
        temperature=0.8,
        max_tokens=64,
        top_p=1,
    )
    ```

  </Tab>
  <Tab title="TypeScript">
    Weave 는 `openai`와 같은 [일반적인 LLM 라이브러리에 대한 호출](/weave/guides/integrations)을 자동으로 추적합니다.

    ```typescript lines
    import OpenAI from 'openai'
    import * as weave from 'weave'

    const client = new OpenAI()

    // Weave Tracing 초기화
    await weave.init('intro-example')

    const response = await client.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'user',
          content: 'How are you?',
        },
      ],
      temperature: 0.8,
      max_tokens: 64,
      top_p: 1,
    });
    ```

    JS / TS 프로젝트를 위한 전체 설정 가이드는 [TypeScript SDK: Third-Party Integration Guide](/weave/guides/integrations/js)를 참조하세요.

  </Tab>
</Tabs>

Call의 `summary` 사전(dictionary)에 메트릭이나 다른 사후 호출 값을 저장할 수 있습니다. 실행 중에 `call.summary`를 수정하면 추가한 모든 값이 호출이 끝날 때 Weave 가 계산한 요약 데이터와 병합됩니다.

### 2. 함수 데코레이팅 및 래핑

하지만 LLM 애플리케이션에는 추적하고 싶은 추가 로직(전처리/후처리, 프롬프트 등)이 있는 경우가 많습니다.

<Tabs>
  <Tab title="Python">
    Weave 를 사용하면 [`@weave.op`](/weave/reference/python-sdk/#function-op) 데코레이터를 사용하여 이러한 호출을 수동으로 추적할 수 있습니다. 예:

    ```python lines lines
    import weave

    # Weave Tracing 초기화
    weave.init('intro-example')

    # 함수 데코레이팅
    @weave.op
    def my_function(name: str):
        return f"Hello, {name}!"

    # 함수 호출 -- Weave가 자동으로 입력과 출력을 추적합니다
    print(my_function("World"))
    ```

    [클래스의 메소드](#4-track-class-and-object-methods)도 추적할 수 있습니다.

    #### 동기 및 비동기 제너레이터 함수 추적

    Weave 는 깊게 중첩된 패턴을 포함하여 동기 및 비동기 제너레이터 함수의 추적을 지원합니다.

    <Warning>
    제너레이터는 값을 느리게(lazily) 생성하므로, 제너레이터가 완전히 소비될 때(예: 리스트로 변환할 때)만 출력이 로그에 기록됩니다.
    trace에 출력이 캡처되도록 하려면 제너레이터를 완전히 소비하세요(예: `list()` 사용).
    </Warning>

    ```python lines lines
    from typing import Generator
    import weave

    weave.init("my-project")

    # 이 함수는 단순한 동기 제너레이터를 사용합니다.
    # Weave는 호출과 입력(`x`)을 추적하지만, 
    # 출력 값은 제너레이터가 소비될 때(예: `list()`를 통해)만 캡처됩니다.
    @weave.op
    def basic_gen(x: int) -> Generator[int, None, None]:
        yield from range(x)

    # 제너레이터 파이프라인 내에서 사용되는 일반 동기 함수입니다.
    # 이 호출들도 Weave에 의해 독립적으로 추적됩니다.
    @weave.op
    def inner(x: int) -> int:
        return x + 1

    # 다른 추적된 함수(`inner`)를 호출하는 동기 제너레이터입니다.
    # 생성된 각 값은 `inner`에 대한 별도의 추적된 호출에서 나옵니다.
    @weave.op
    def nested_generator(x: int) -> Generator[int, None, None]:
        for i in range(x):
            yield inner(i)

    # 위 제너레이터를 구성하는 더 복잡한 제너레이터입니다.
    # 여기서 추적하면 계층적인 call 트리가 생성됩니다:
    # - `deeply_nested_generator` (부모)
    #   - `nested_generator` (자식)
    #     - `inner` (손자)
    @weave.op
    def deeply_nested_generator(x: int) -> Generator[int, None, None]:
        for i in range(x):
            for j in nested_generator(i):
                yield j

    # Weave가 출력을 캡처하려면 제너레이터가 *소비*되어야 합니다.
    # 이는 동기 및 비동기 제너레이터 모두에 해당됩니다.
    res = deeply_nested_generator(4)
    list(res)  # 모든 중첩된 호출과 yield의 추적을 트리거합니다.
    ```
    
    ![Weave에서 제너레이터 함수 추적하기.](/weave/guides/tracking/imgs/generators.png)

  </Tab>
  <Tab title="TypeScript">
    Weave 를 사용하면 [`weave.op`](/weave/reference/typescript-sdk/functions/op)으로 함수를 래핑하여 이러한 호출을 수동으로 추적할 수 있습니다. 예:

    ```typescript lines
    import * as weave from 'weave'

    await weave.init('intro-example')

    function myFunction(name: string) {
        return `Hello, ${name}!`
    }

    const myFunctionOp = weave.op(myFunction)
    ```

    인라인으로 래핑을 정의할 수도 있습니다:

    ```typescript
    const myFunctionOp = weave.op((name: string) => `Hello, ${name}!`)
    ```

    이것은 함수뿐만 아니라 클래스의 메소드에도 작동합니다:

    ```typescript
    class MyClass {
        constructor() {
            this.myMethod = weave.op(this.myMethod)
        }

        myMethod(name: string) {
            return `Hello, ${name}!`
        }
    }
    ```
  </Tab>
</Tabs>

#### 실행 중에 call 오브젝트 핸들 가져오기

<Tabs>
  <Tab title="Python">
    가끔 `Call` 오브젝트 자체에 대한 핸들을 가져오는 것이 유용할 때가 있습니다. 결과와 `Call` 오브젝트를 모두 반환하는 `op.call` 메소드를 호출하여 이를 수행할 수 있습니다. 예:

    ```python lines lines
    result, call = my_function.call("World")
    ```

    그런 다음 `call`을 사용하여 추가 속성을 설정, 업데이트 또는 가져올 수 있습니다 (피드백에 사용할 호출 ID를 가져오는 데 가장 흔히 사용됨).

    <Note>
    op이 클래스의 메소드인 경우, 인스턴스를 op의 첫 번째 인수로 전달해야 합니다 (아래 예시 참조).
    </Note>
    ```python lines lines
    # 인스턴스를 첫 번째 인수로 전달하는 것에 주의하세요.
    print(instance.my_method.call(instance, "World"))
    ```

    ```python lines lines
    import weave

    # Weave Tracing 초기화
    weave.init("intro-example")

    class MyClass:
        # 메소드 데코레이팅
        @weave.op
        def my_method(self, name: str):
            return f"Hello, {name}!"

    instance = MyClass()

    # 메소드 호출 -- Weave가 자동으로 입력과 출력을 추적합니다
    instance.my_method.call(instance, "World")
    ```
  </Tab>
  <Tab title="TypeScript">
    ```plaintext
    이 기능은 아직 TypeScript SDK에서 사용할 수 없습니다.
    ```
  </Tab>
</Tabs>

#### 실행 시 call 표시 이름 설정

<Tabs>
  <Tab title="Python">
    가끔 호출의 표시 이름을 오버라이드하고 싶을 수 있습니다. 다음 네 가지 방법 중 하나로 이를 수행할 수 있습니다:

    1. op을 호출할 때 표시 이름을 변경합니다:

    ```python lines lines
    result = my_function("World", __weave={"display_name": "My Custom Display Name"})
    ```

    <Note>
    `__weave` 사전을 사용하면 호출 표시 이름을 설정하며, 이는 Op 표시 이름보다 우선합니다.
    </Note>
    2. 호출별로 표시 이름을 변경합니다. 이는 `Call` 오브젝트를 반환하는 [`Op.call`](/weave/reference/python-sdk/trace/op#function-call) 메소드를 사용하며, 그런 다음 [`Call.set_display_name`](/weave/reference/python-sdk/trace/weave_client#method-set_display_name)을 사용하여 표시 이름을 설정할 수 있습니다.
    ```python lines lines
    result, call = my_function.call("World")
    call.set_display_name("My Custom Display Name")
    ```

    3. 특정 Op의 모든 Calls에 대해 표시 이름을 변경합니다:

    ```python lines lines
    @weave.op(call_display_name="My Custom Display Name")
    def my_function(name: str):
        return f"Hello, {name}!"
    ```

    4. `call_display_name`은 `Call` 오브젝트를 받아 문자열을 반환하는 함수일 수도 있습니다. 함수가 호출될 때 `Call` 오브젝트가 자동으로 전달되므로, 함수의 이름, 호출 입력, 필드 등을 기반으로 동적으로 이름을 생성할 수 있습니다.

    1. 일반적인 유스 케이스 중 하나는 함수 이름에 타임스탬프를 추가하는 것입니다.

        ```py
        from datetime import datetime

        @weave.op(call_display_name=lambda call: f"{call.func_name}__{datetime.now()}")
        def func():
            return ...
        ```

    2. `.attributes`를 사용하여 커스텀 메타데이터를 기록할 수도 있습니다.

        ```py
        def custom_attribute_name(call):
            model = call.attributes["model"]
            revision = call.attributes["revision"]
            now = call.attributes["date"]

            return f"{model}__{revision}__{now}"

        @weave.op(call_display_name=custom_attribute_name)
        def func():
            return ...

        with weave.attributes(
            {
                "model": "finetuned-llama-3.1-8b",
                "revision": "v0.1.2",
                "date": "2024-08-01",
            }
        ):
            func()  # 표시 이름은 "finetuned-llama-3.1-8b__v0.1.2__2024-08-01"이 됩니다.

            with weave.attributes(
                {
                    "model": "finetuned-gpt-4o",
                    "revision": "v0.1.3",
                    "date": "2024-08-02",
                }
            ):
                func()  # 표시 이름은 "finetuned-gpt-4o__v0.1.3__2024-08-02"가 됩니다.
        ```

    **기술 참고:** "Calls"는 "Ops"에 의해 생성됩니다. Op은 `@weave.op`으로 데코레이팅된 함수 또는 메소드입니다. 
    기본적으로 Op의 이름은 함수 이름이며, 연관된 호출들도 동일한 표시 이름을 갖게 됩니다. 위의 예시는 특정 Op의 모든 Calls에 대해 표시 이름을 오버라이드하는 방법을 보여줍니다. 가끔 사용자는 Op 자체의 이름을 오버라이드하고 싶어 합니다. 이는 다음 두 가지 방법 중 하나로 가능합니다:

    1. 호출이 로깅되기 전에 Op의 `name` 속성을 설정합니다.
    ```python lines lines
    my_function.name = "My Custom Op Name"
    ```

    2. op 데코레이터에서 `name` 옵션을 설정합니다.
    ```python lines lines
    @weave.op(name="My Custom Op Name")
    ```
  </Tab>
  <Tab title="TypeScript">
  호출의 기본 이름을 오버라이드하려면 `weave.op()`을 호출할 때 `callDisplayName` 옵션을 사용하세요.

    ```typescript lines {2}
    const extractDinosOp = weave.op(extractDinos, {
    callDisplayName: (input: string) => `Your New Display Name`
    });
    ```

    실행 후에도 [호출의 표시 이름을 업데이트](/weave/guides/tracking/tracing#set-display-name)할 수 있습니다.
  </Tab>
</Tabs>

#### 병렬(멀티 스레드) 함수 호출 추적

<Tabs>
  <Tab title="Python">
    기본적으로 병렬 호출은 Weave 에서 모두 별도의 루트 호출로 나타납니다. 동일한 부모 `op` 아래에 올바르게 중첩되게 하려면 [`ThreadPoolExecutor`](/weave/reference/python-sdk/trace/util#class-contextawarethreadpoolexecutor)를 사용하세요.

    다음 코드 샘플은 `ThreadPoolExecutor` 사용법을 보여줍니다. 
    첫 번째 함수인 `func`는 `x`를 받아 `x+1`을 반환하는 간단한 `op`입니다. 두 번째 함수인 `outer`는 입력 리스트를 받는 또 다른 `op`입니다. 
    `outer` 내부에서 `ThreadPoolExecutor`와 `exc.map(func, inputs)`를 사용하면 `func`에 대한 각 호출이 여전히 동일한 부모 trace 컨텍스트를 유지합니다.

    ```python lines
    import weave

    @weave.op
    def func(x):
        return x+1

    @weave.op
    def outer(inputs):
        with weave.ThreadPoolExecutor() as exc:
            exc.map(func, inputs)

    # Weave 프로젝트 이름 업데이트
    client = weave.init('my-weave-project')
    outer([1,2,3,4,5])
    ```

    Weave UI에서 이는 단일 부모 호출과 5개의 중첩된 자식 호출을 생성하므로, 증분 작업이 병렬로 실행되더라도 완전한 계층적 trace를 얻을 수 있습니다.

    ![Trace UI, `outer`에 대한 단일 부모 호출과 5개의 중첩된 자식 호출을 보여줍니다.](/weave/guides/tracking/imgs/threadpoolexecutor.png)
  </Tab>
  <Tab title="TypeScript">
  ```plaintext
  이 기능은 아직 TypeScript SDK에서 사용할 수 없습니다.
  ```
  </Tab>
</Tabs>

### 3. 수동 Call 추적

API를 직접 사용하여 수동으로 Calls를 생성할 수도 있습니다.

<Tabs>
    <Tab title="Python">

        ```python lines lines
        import weave

        # Weave Tracing 초기화
        client = weave.init('intro-example')

        def my_function(name: str):
            # 호출 시작
            call = client.create_call(op="my_function", inputs={"name": name})

            # ... 함수 코드 ...

            # 호출 종료
            client.finish_call(call, output="Hello, World!")

        # 함수 호출
        print(my_function("World"))
        ```

    </Tab>
    <Tab title="TypeScript">

    ```plaintext
    이 기능은 아직 TypeScript SDK에서 사용할 수 없습니다.
    ```

    </Tab>

    <Tab title="HTTP API">
    * 호출 시작: [POST `/call/start`](https://docs.wandb.ai/weave/reference/service-api/calls/call-start)
    * 호출 종료: [POST `/call/end`](https://docs.wandb.ai/weave/reference/service-api/calls/call-end)
    ```bash
    curl -L 'https://trace.wandb.ai/call/start' \
    -H 'Content-Type: application/json' \
    -H 'Accept: application/json' \
    -d '{
        "start": {
            "project_id": "string",
            "id": "string",
            "op_name": "string",
            "display_name": "string",
            "trace_id": "string",
            "parent_id": "string",
            "started_at": "2024-09-08T20:07:34.849Z",
            "attributes": {},
            "inputs": {},
            "wb_run_id": "string"
        }
    }
    ```
    </Tab>
</Tabs>

### 4. 클래스 및 오브젝트 메소드 추적

클래스 및 오브젝트 메소드도 추적할 수 있습니다.

<Tabs>
    <Tab title="Python">
    `weave.op`을 사용하여 클래스의 모든 메소드를 추적합니다.

    ```python lines lines
    import weave

    # Weave Tracing 초기화
    weave.init("intro-example")

    class MyClass:
        # 메소드 데코레이팅
        @weave.op
        def my_method(self, name: str):
            return f"Hello, {name}!"

    instance = MyClass()

    # 메소드 호출 -- Weave가 자동으로 입력과 출력을 추적합니다
    print(instance.my_method("World"))
    ```

    </Tab>
    <Tab title="TypeScript">

    <Important>
    **TypeScript에서 데코레이터 사용하기**

    TypeScript 코드에서 `@weave.op` 데코레이터를 사용하려면 환경이 올바르게 설정되어 있는지 확인하세요:

    - **TypeScript v5.0 이상**: 데코레이터가 기본적으로 지원되며 추가 설정이 필요하지 않습니다.
    - **TypeScript v5.0 미만**: 데코레이터에 대한 실험적 지원을 활성화합니다. 자세한 내용은 [데코레이터에 관한 공식 TypeScript 문서](https://www.typescriptlang.org/docs/handbook/decorators.html)를 참조하세요.
    </Important>
    #### 클래스 메소드 데코레이팅

    인스턴스 메소드를 추적하려면 `@weave.op`을 사용하세요.

    ```typescript
    class Foo {
        @weave.op
        async predict(prompt: string) {
            return "bar"
        }
    }
    ```

    #### 정적 클래스 메소드 데코레이팅

    클래스 내의 유틸리티 함수를 모니터링하려면 정적 메소드에 `@weave.op`을 적용하세요.

    ```typescript
    class MathOps {
        @weave.op
        static square(n: number): number {
            return n * n;
        }
    }
    ```

    </Tab>
</Tabs>

## Viewing Calls

<Tabs>
<Tab title="Web App">
웹 앱에서 호출을 보려면 다음 단계를 따르세요:
1. 프로젝트의 **Traces** 탭으로 이동합니다.
2. 목록에서 보려는 호출을 찾습니다.
3. 호출을 클릭하여 상세 페이지를 엽니다.

상세 페이지에는 호출의 입력, 출력, 런타임 및 추가 메타데이터가 표시됩니다.

![Web App에서 Call 보기](/images/screenshots/basic_call.png)
</Tab>
<Tab title="Python">
Weave Python SDK를 사용하여 호출을 보려면 [`get_call`](/weave/reference/python-sdk/trace/weave_client#method-get_call) 메소드를 사용할 수 있습니다:

```python lines
import weave

# 클라이언트 초기화
client = weave.init("your-project-name")

# ID로 특정 호출 가져오기
call = client.get_call("call-uuid-here")

print(call)
```
</Tab>
<Tab title="TypeScript">
```typescript lines
import * as weave from 'weave'

// 클라이언트 초기화
const client = await weave.init('intro-example')

// ID로 특정 호출 가져오기
const call = await client.getCall('call-uuid-here')

console.log(call)
```
</Tab>

<Tab title="HTTP API">
Service API를 사용하여 호출을 보려면 [`/call/read`](https://docs.wandb.ai/weave/reference/service-api/calls/call-read) 엔드포인트에 요청을 보낼 수 있습니다.

```bash
curl -L 'https://trace.wandb.ai/call/read' \
-H 'Content-Type: application/json' \
-H 'Accept: application/json' \
-d '{
    "project_id": "string",
    "id": "string",
}'
```
</Tab>
</Tabs>

### `weave.Markdown`으로 렌더링된 traces 커스터마이징

`weave.Markdown`을 사용하면 원본 데이터를 잃지 않고 trace 정보가 표시되는 방식을 커스터마이징할 수 있습니다. 이를 통해 기본 데이터 구조를 보존하면서 입력과 출력을 읽기 쉬운 형식의 콘텐츠 블록으로 렌더링할 수 있습니다.

<Tabs>
<Tab title="Python">
`@weave.op` 데코레이터에서 `postprocess_inputs` 및 `postprocess_output` 함수를 사용하여 trace 데이터를 포맷팅하세요. 다음 코드 샘플은 포스트프로세서를 사용하여 Weave 에서 이모지와 더 읽기 쉬운 포맷팅으로 호출을 렌더링합니다:
    
```python lines
import weave

def postprocess_inputs(query) -> weave.Markdown:
    search_box = f"""
**Search Query:**
``+`
{query}
``+`
"""
    return {"search_box": weave.Markdown(search_box),
            "query": query}

def postprocess_output(docs) -> weave.Markdown:
    formatted_docs = f"""
# {docs[0]["title"]}

{docs[0]["content"]}

[Read more]({docs[0]["url"]})

---

# {docs[1]["title"]}

{docs[1]["content"]}

[Read more]({docs[1]["url"]})
"""
    return weave.Markdown(formatted_docs)

@weave.op(
    postprocess_inputs=postprocess_inputs,
    postprocess_output=postprocess_output,
)
def rag_step(query):
    # S&P 500 기업들에 대한 예시 신문 기사들
    docs = [
        {
            "title": "OpenAI",
            "content": "OpenAI is a company that makes AI models.",
            "url": "https://www.openai.com",
        },
        {
            "title": "Google",
            "content": "Google is a company that makes search engines.",
            "url": "https://www.google.com",
        },
    ]
    return docs

if __name__ == "__main__":
    weave.init('markdown_renderers')
    rag_step("Tell me about OpenAI")
```
</Tab>
<Tab title="Typescript">
```plaintext
이 기능은 아직 TypeScript SDK에서 사용할 수 없습니다.
```
</Tab>
</Tabs>
다음 스크린샷에서 각각 포맷팅되지 않은 출력과 포맷팅된 출력 사이의 차이점을 확인할 수 있습니다.

![코드 샘플을 사용하여 Weave UI에서 렌더링된 호출.](/weave/guides/tracking/imgs/md-call-render.png)

## Updating Calls

Calls는 생성된 후에는 대부분 불변이지만, 지원되는 몇 가지 변형 작업이 있습니다:
* [표시 이름 설정](#set-display-name)
* [피드백 추가](#add-feedback)
* [Call 삭제](#delete-a-call)

호출 상세 페이지로 이동하여 UI에서 이러한 모든 작업을 수행할 수 있습니다:

<Frame>
![Web App에서 Call 업데이트](/images/call_edit_screenshot.png)
</Frame>

### 표시 이름 설정

<Tabs>
<Tab title="Python">
호출의 표시 이름을 설정하려면 [`Call.set_display_name()`](/weave/reference/python-sdk/trace/weave_client#method-set-display-name) 메소드를 사용할 수 있습니다.

```python lines lines
import weave

# 클라이언트 초기화
client = weave.init("your-project-name")

# ID로 특정 호출 가져오기
call = client.get_call("call-uuid-here")

# 호출의 표시 이름 설정
call.set_display_name("My Custom Display Name")
```
</Tab>
<Tab title="TypeScript">
호출의 표시 이름을 설정하려면 [`client.updateCall`](/weave/reference/typescript-sdk/classes/weaveclient#updatecall)을 사용하여 호출 ID로 직접 업데이트하세요:

```typescript lines
import * as weave from 'weave'

// 클라이언트 초기화
const client = await weave.init('your-project-name')

// ID로 호출의 표시 이름 업데이트
await client.updateCall('call-uuid-here', 'My Custom Display Name')
```

</Tab>
<Tab title="HTTP API">
Service API를 사용하여 호출의 표시 이름을 설정하려면 [`/call/update`](https://docs.wandb.ai/weave/reference/service-api/calls/call-update) 엔드포인트에 요청을 보낼 수 있습니다.

```bash
curl -L 'https://trace.wandb.ai/call/update' \
-H 'Content-Type: application/json' \
-H 'Accept: application/json' \
-d '{
    "project_id": "string",
    "call_id": "string",
    "display_name": "string",
}'
```
    </Tab>
</Tabs>

[실행 시 호출의 표시 이름을 설정](#set-call-display-name-at-execution)할 수도 있습니다.

### 피드백 추가 

자세한 내용은 [Feedback Documentation](/weave/guides/tracking/feedback)을 참조하세요.

### Call 삭제

<Tabs>
<Tab title="Python">
Python API를 사용하여 Call을 삭제하려면 [`Call.delete`](/weave/reference/python-sdk/trace/weave_client#method-delete) 메소드를 사용할 수 있습니다.

```python lines lines
import weave

# 클라이언트 초기화
client = weave.init("your-project-name")

# ID로 특정 호출 가져오기
call = client.get_call("call-uuid-here")

# 호출 삭제
call.delete()
```

</Tab>
<Tab title="TypeScript">
```plaintext
이 기능은 아직 TypeScript SDK에서 사용할 수 없습니다.
```
</Tab>
<Tab title="HTTP API">
Service API를 사용하여 호출을 삭제하려면 [`/calls/delete`](https://docs.wandb.ai/weave/reference/service-api/calls/calls-delete) 엔드포인트에 요청을 보낼 수 있습니다.

```bash
curl -L 'https://trace.wandb.ai/calls/delete' \
-H 'Content-Type: application/json' \
-H 'Accept: application/json' \
-d '{
    "project_id": "string",
    "call_ids": [
        "string"
    ],
}'
```
</Tab>
</Tabs>

### 여러 Calls 삭제

<Tabs>
    <Tab title="Python">
    Python API를 사용하여 여러 Calls를 일괄 삭제하려면 Call ID 목록을 `delete_calls()`에 전달하세요.

    <Important>
    - 한 번에 삭제할 수 있는 최대 Calls 수는 `1000`개입니다.
    - Call을 삭제하면 모든 자식 호출도 삭제됩니다.
    </Important>

    ```python lines lines
    import weave

    # 클라이언트 초기화
    client = weave.init("my-project")

    # 클라이언트에서 모든 호출 가져오기
    all_calls = client.get_calls()

    # 처음 1000개의 Call 오브젝트 리스트 가져오기
    first_1000_calls = all_calls[:1000]

    # 처음 1000개의 Call ID 리스트 가져오기
    first_1000_calls_ids = [c.id for c in first_1000_calls]

    # ID로 처음 1000개의 Call 오브젝트 삭제
    client.delete_calls(call_ids=first_1000_calls_ids)
    ```

    </Tab>
    <Tab title="TypeScript">
    ```plaintext
    이 기능은 아직 TypeScript SDK에서 사용할 수 없습니다.
    ```
    </Tab>
</Tabs>

## Querying and exporting Calls

<Frame>
![많은 호출들의 스크린샷](/images/screenshots/calls_filter.png)
</Frame>

프로젝트의 `/calls` 페이지("Traces" 탭)에는 프로젝트의 모든 Calls에 대한 테이블 뷰가 포함되어 있습니다. 여기에서 다음을 수행할 수 있습니다:
* 정렬
* 필터링
* 내보내기

<Frame>
![Calls Table View](/images/export_modal.png)
</Frame>

내보내기 모달(위 그림 참조)을 사용하면 다양한 형식으로 데이터를 내보낼 수 있을 뿐만 아니라, 선택한 호출에 해당하는 Python 및 CURL 코드를 보여줍니다!
가장 쉽게 시작하는 방법은 UI에서 뷰를 구성한 다음, 생성된 코드 조각을 통해 내보내기 API에 대해 자세히 알아보는 것입니다.

<Tabs>
    <Tab title="Python">
    Python API를 사용하여 호출을 가져오려면 [`client.get_calls`](/weave/reference/python-sdk/trace/weave_client#method-get_calls) 메소드를 사용할 수 있습니다:

    ```python lines
    import weave

    # 클라이언트 초기화
    client = weave.init("your-project-name")

    # 호출 가져오기
    calls = client.get_calls(filter=...)
    ```

    </Tab>
    <Tab title="TypeScript">
    TypeScript API를 사용하여 호출을 가져오려면 [`client.getCalls`](/weave/reference/typescript-sdk/classes/weaveclient#getcalls) 메소드를 사용할 수 있습니다.
    ```typescript
    import * as weave from 'weave'

    // 클라이언트 초기화
    const client = await weave.init('intro-example')

    // 호출 가져오기
    const calls = await client.getCalls(filter=...)
    ```
    </Tab>
    <Tab title="HTTP API">
    가장 강력한 쿼리 레이어는 Service API에 있습니다. Service API를 사용하여 호출을 가져오려면 [`/calls/stream_query`](https://docs.wandb.ai/weave/reference/service-api/calls/calls-query-stream) 엔드포인트에 요청을 보낼 수 있습니다.

    ```bash
    curl -L 'https://trace.wandb.ai/calls/stream_query' \
    -H 'Content-Type: application/json' \
    -H 'Accept: application/json' \
    -d '{
    "project_id": "string",
    "filter": {
        "op_names": [
            "string"
        ],
        "input_refs": [
            "string"
        ],
        "output_refs": [
            "string"
        ],
        "parent_ids": [
            "string"
        ],
        "trace_ids": [
            "string"
        ],
        "call_ids": [
            "string"
        ],
        "trace_roots_only": true,
        "wb_user_ids": [
            "string"
        ],
        "wb_run_ids": [
            "string"
        ]
    },
    "limit": 100,
    "offset": 0,
    "sort_by": [
        {
        "field": "string",
        "direction": "asc"
        }
    ],
    "query": {
        "$expr": {}
    },
    "include_costs": true,
    "include_feedback": true,
    "columns": [
        "string"
    ],
    "expand_columns": [
        "string"
    ]
    }'
    ```
    </Tab>
</Tabs>

### Call 스키마

필드 전체 목록은 [스키마](/weave/reference/python-sdk/trace_server/trace_server_interface#class-callschema)를 참조하세요.

| 속성 | 타입 | 설명 |
|----------|------|-------------|
| `id` | string (uuid) | 호출의 고유 식별자 |
| `project_id` | string (선택사항) | 연관된 프로젝트 식별자 |
| `op_name` | string | 연산의 이름 (참조일 수 있음) |
| `display_name` | string (선택사항) | 호출에 대한 사용자 친화적인 이름 |
| `trace_id` | string (uuid) | 이 호출이 속한 trace의 식별자 |
| `parent_id` | string (uuid) | 부모 호출의 식별자 |
| `started_at` | datetime | 호출이 시작된 시점의 타임스탬프 |
| `attributes` | Dict[str, Any] | 호출에 대한 사용자 정의 메타데이터 *(실행 중 읽기 전용)* |
| `inputs` | Dict[str, Any] | 호출에 대한 입력 파라미터 |
| `ended_at` | datetime (선택사항) | 호출이 종료된 시점의 타임스탬프 |
| `exception` | string (선택사항) | 호출 실패 시 에러 메시지 |
| `output` | Any (선택사항) | 호출의 결과 |
| `summary` | Optional[SummaryMap] | 실행 후 요약 정보. 실행 중에 이를 수정하여 커스텀 메트릭을 기록할 수 있습니다. |
| `wb_user_id` | Optional[str] | 연관된 Weights & Biases 사용자 ID |
| `wb_run_id` | Optional[str] | 연관된 Weights & Biases run ID |
| `deleted_at` | datetime (선택사항) | 호출 삭제 시점의 타임스탬프 (해당하는 경우) |

위 테이블은 Weave 에서 Call의 주요 속성을 개략적으로 설명합니다. 각 속성은 함수 호출을 추적하고 관리하는 데 중요한 역할을 합니다:

- `id`, `trace_id`, `parent_id` 필드는 시스템 내에서 호출을 정리하고 관련짓는 데 도움이 됩니다.
- 시간 정보(`started_at`, `ended_at`)를 통해 성능 분석이 가능합니다.
- `attributes` 및 `inputs` 필드는 호출에 대한 컨텍스트를 제공합니다. Attributes는 호출이 시작되면 고정되므로 호출 전에 `weave.attributes`로 설정해야 합니다. `output` 및 `summary`는 결과를 캡처하며, 실행 중에 `summary`를 업데이트하여 추가 메트릭을 로깅할 수 있습니다.
- Weights & Biases와의 인테그레이션은 `wb_user_id` 및 `wb_run_id`를 통해 용이해집니다.

이러한 포괄적인 속성 세트를 통해 프로젝트 전체에서 함수 호출에 대한 상세한 추적 및 분석이 가능합니다.

계산된 필드:
    * 비용
    * 기간
    * 상태

## Saved views 

Trace 테이블 구성, 필터 및 정렬을 _저장된 뷰_로 저장하여 선호하는 설정에 빠르게 엑세스할 수 있습니다. UI 및 Python SDK를 통해 저장된 뷰를 구성하고 엑세스할 수 있습니다. 자세한 내용은 [Saved Views](/weave/guides/tools/saved-views)를 참조하세요.

## Traces 테이블에서 W&B run 보기

Weave 를 사용하면 코드의 함수 호출을 추적하고 이들이 실행된 [W&B runs](https://docs.wandb.ai/models/runs/)에 직접 링크할 수 있습니다. 
@weave.op()으로 함수를 추적하고 wandb.init() 컨텍스트 내에서 호출하면, Weave 는 자동으로 해당 trace를 W&B run과 연결합니다. 
연관된 runs에 대한 링크는 Traces 테이블에 표시됩니다.

<Tabs>
<Tab title="Python">
다음 Python 코드는 `wandb.init()` 컨텍스트 내에서 실행될 때 추적된 작업이 어떻게 W&B runs에 연결되는지 보여줍니다. 이러한 traces는 Weave UI에 나타나며 해당 run과 연관됩니다.

```python lines 
import wandb
import weave

def example_wandb(projname):
    # projname을 entity와 project로 분리
    entity, project = projname.split("/", 1)

    # 추적을 위한 Weave 컨텍스트 초기화
    weave.init(projname)

    # 추적 가능한 작업 정의
    @weave.op()
    def say(message: str) -> str:
        return f"I said: {message}"

    # 첫 번째 W&B run
    with wandb.init(
        entity=entity,
        project=project,
        notes="Experiment 1",
        tags=["baseline", "paper1"],
    ) as run:
        say("Hello, world!")
        say("How are you!")
        run.log({"messages": 2})

    # 두 번째 W&B run
    with wandb.init(
        entity=entity,
        project=project,
        notes="Experiment 2",
        tags=["baseline", "paper1"],
    ) as run:
        say("Hello, world from experiment 2!")
        say("How are you!")
        run.log({"messages": 2})

if __name__ == "__main__":
    # 실제 W&B username/project로 교체하세요
    example_wandb("your-username/your-project")
```

코드 샘플 사용 방법:

1. 터미널에서 의존성 설치:

```bash
pip install wandb weave
```

2. W&B 로그인:

```bash
wandb login
```

3. 스크립트에서 `your-username/your-project`를 실제 W&B entity/project로 변경합니다.
4. 스크립트 실행:

```bash
python weave_trace_with_wandb.py
```
5. [https://weave.wandb.ai](https://weave.wandb.ai)에 접속하여 프로젝트를 선택합니다.
6. **Traces** 탭에서 trace 결과를 확인합니다. 연관된 runs에 대한 링크가 Traces 테이블에 표시됩니다.
</Tab>
<Tab title="TypeScript">
```plaintext
이 기능은 아직 TypeScript SDK에서 사용할 수 없습니다.
```
</Tab>
</Tabs>

## Configure autopatching

기본적으로 Weave 는 `openai`, `anthropic`, `cohere`, `mistral`과 같은 일반적인 LLM 라이브러리에 대한 호출을 자동으로 패치하고 추적합니다.

<Tabs>
<Tab title="Python">
<Warning>
`autopatch_settings` 인수는 지원이 중단될 예정입니다. 암시적 패치를 비활성화하려면 `implicitly_patch_integrations=False`를 사용하거나, 인테그레이션별로 설정을 구성하려면 `patch_openai(settings={...})`와 같은 특정 패치 함수를 호출하세요.
</Warning>

### 모든 autopatching 비활성화

```python lines
weave.init(..., implicitly_patch_integrations=False)
```

### 특정 인테그레이션 활성화

```python lines
import weave

weave.init(..., implicitly_patch_integrations=False)

# 그런 다음 원하는 인테그레이션만 수동으로 패치합니다
weave.integrations.patch_anthropic()
weave.integrations.patch_cohere()
```

### 입력 및 출력 후처리

패치 함수에 설정을 전달하여 입력 및 출력(예: PII 데이터) 처리 방식을 커스터마이징할 수 있습니다:

```python lines
import weave.integrations

def redact_inputs(inputs: dict) -> dict:
    if "email" in inputs:
        inputs["email"] = "[REDACTED]"
    return inputs

weave.init(...)
weave.integrations.patch_openai(
    settings={
        "op_settings": {"postprocess_inputs": redact_inputs}
    }
)
```
</Tab>
<Tab title="TypeScript">

TypeScript SDK는 OpenAI 및 Anthropic에 대한 autopatching만 지원합니다. OpenAI는 Weave 를 임포트할 때 자동으로 패치되며 추가 설정이 필요하지 않습니다.

또한 TypeScript SDK는 다음을 지원하지 않습니다:
- autopatching 구성 또는 비활성화
- 입력/출력 후처리

자동 패치가 작동하지 않는 엣지 케이스(ESM, Next.js와 같은 번들러)의 경우 명시적 래핑을 사용하세요:

```typescript
import OpenAI from 'openai'
import * as weave from 'weave'
import { wrapOpenAI } from 'weave'

const client = wrapOpenAI(new OpenAI())
await weave.init('your-team/my-project')
```

ESM 설정 및 문제 해결에 대한 자세한 내용은 [TypeScript SDK Integration Guide](/weave/guides/integrations/js)를 참조하세요.
</Tab>
</Tabs>
자세한 내용은 [How to use Weave with PII data](/weave/cookbooks/pii)를 참조하세요.

## FAQs

### 대규모 trace가 잘리는 현상을 어떻게 방지하나요?

자세한 내용은 [문제 해결 가이드](/weave/guides/troubleshooting)의 [Trace 데이터가 잘림](/weave/guides/troubleshooting#trace-data-is-truncated) 섹션을 참조하세요.

### 추적을 어떻게 비활성화하나요?

#### 환경 변수

프로그램 전체에 대해 무조건적으로 추적을 비활성화하고 싶은 경우, 환경 변수 `WEAVE_DISABLED=true`를 설정할 수 있습니다.

#### 클라이언트 초기화

때로는 특정 조건에 따라 특정 초기화에 대해서만 추적을 활성화하고 싶을 수 있습니다. 이 경우 init 설정에서 `disabled` 플래그로 클라이언트를 초기화할 수 있습니다.

<Tabs>
<Tab title="Python">
```python lines
import weave

# 클라이언트 초기화
client = weave.init(..., settings={"disabled": True})
```
</Tab>
<Tab title="TypeScript">
```plaintext
이 기능은 아직 TypeScript SDK에서 사용할 수 없습니다.
```
</Tab>
</Tabs>

#### 컨텍스트 매니저

마지막으로, 애플리케이션 로직에 따라 단일 함수에 대해서만 추적을 비활성화하고 싶을 수 있습니다. 이 경우 `weave.trace.context.call_context`에서 임포트할 수 있는 `with set_tracing_enabled(False)` 컨텍스트 매니저를 사용할 수 있습니다.

```python lines
import weave
from weave.trace.context.call_context import set_tracing_enabled

client = weave.init(...)

@weave.op
def my_op():
    ...

with set_tracing_enabled(False):
    my_op()
```

### Call에 대한 정보를 어떻게 캡처하나요?

일반적으로 op을 직접 호출합니다:

```python lines
@weave.op
def my_op():
    ...

my_op()
```

하지만 op에서 `call` 메소드를 호출하여 호출 오브젝트에 직접 엑세스할 수도 있습니다:

```python lines
@weave.op
def my_op():
    ...

output, call = my_op.call()
```

여기서 `call` 오브젝트는 입력, 출력 및 기타 메타데이터를 포함하여 호출에 대한 모든 정보를 담고 있습니다.
```python lines
@weave.op
def my_op():
    ...

output, call = my_op.call()
```