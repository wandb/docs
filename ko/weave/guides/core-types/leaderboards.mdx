---
title: "모델 비교 및 순위 매기기"
description: "평가 메트릭을 기반으로 서로 다른 모델 버전을 비교하고 순위를 매깁니다"
---

Weave _Leaderboards_를 사용하면 여러 메트릭 전반에서 여러 모델을 평가하고 비교하여 정확도, 생성 품질, 지연 시간 또는 사용자 정의 평가 로직을 측정할 수 있습니다. 리더보드는 단일 위치에서 모델 성능을 시각화하고, 시간에 따른 변화를 추적하며, 팀 전체에서 공통 벤치마크를 설정하는 데 도움을 줍니다.

리더보드는 다음과 같은 경우에 적합합니다:

- 모델 성능 회귀(성능 저하) 추적
- 공유 평가 워크플로우 조율

<Note>
리더보드 생성은 Weave UI 및 Weave Python SDK에서만 사용할 수 있습니다. TypeScript 사용자는 [Weave UI](#using-the-ui)를 사용하여 리더보드를 생성하고 관리할 수 있습니다.
</Note>

<div id="create-a-leaderboard">
  ## 리더보드 생성
</div>

[Weave UI](#ui) 또는 [프로그래밍 방식](#python)으로 리더보드를 생성할 수 있습니다.

<div id="using-the-ui">
  ### UI 사용하기
</div>

Weave UI에서 바로 리더보드를 생성하고 사용자 지정하려면:

1. Weave UI에서 **Leaders** 섹션으로 이동합니다. 보이지 않으면 **More** → **Leaders**를 클릭합니다.
2. **+ New Leaderboard**를 클릭합니다.
3. **Leaderboard Title** 필드에 설명적인 이름을 입력합니다(예: `summarization-benchmark-v1`).
4. 필요하다면, 이 리더보드가 무엇을 비교하는지 설명을 추가합니다.
5. 표시할 평가와 메트릭을 정의하기 위해 [열을 추가](#add-columns)합니다.
6. 레이아웃이 마음에 들면 리더보드를 저장하고 게시하여 다른 사람과 공유합니다.

<div id="add-columns">
  #### 열 추가
</div>

리더보드의 각 열은 특정 평가에서 나온 메트릭을 나타냅니다. 열을 설정하려면 다음을 지정합니다:

- **Evaluation**: 드롭다운에서 평가 run을 선택합니다(먼저 생성되어 있어야 합니다).
- **Scorer**: 해당 평가에서 사용된 스코어링 함수(예: `jaccard_similarity`, `simple_accuracy`)를 선택합니다.
- **Metric**: 표시할 요약 메트릭(예: `mean`, `true_fraction` 등)을 선택합니다.

열을 더 추가하려면 **Add Column**을 클릭합니다.

열을 편집하려면 오른쪽의 점 3개 메뉴(`⋯`)를 클릭합니다. 다음 작업을 수행할 수 있습니다:

- **Move before / after** – 열 순서 변경
- **Duplicate** – 열 정의 복사
- **Delete** – 열 삭제
- **Sort ascending** – 리더보드의 기본 정렬 순서 설정(다시 클릭하면 내림차순으로 전환됩니다)

<div id="python">
  ### Python
</div>

<Tip>
바로 실행해볼 수 있는 전체 코드 예제가 필요하신가요? [엔드 투 엔드 Python 예제](#end-to-end-python-example)를 확인하세요.
</Tip>

리더보드를 생성하고 게시하려면 다음 단계를 따르세요.

1. 테스트 데이터셋을 정의합니다. 내장된 [`Dataset`](./datasets)을 사용하거나, 입력과 타깃 목록을 수동으로 정의할 수 있습니다:

   ```python lines
   dataset = [
       {"input": "...", "target": "..."},
       ...
   ]
   ```

2. 하나 이상의 [scorer](../evaluation/scorers)를 정의합니다:

   ```python lines
   @weave.op
   def jaccard_similarity(target: str, output: str) -> float:
       ...
   ```

3. [`Evaluation`](../core-types/evaluations)을 생성합니다:

   ```python lines
   evaluation = weave.Evaluation(
       name="My Eval",
       dataset=dataset,
       scorers=[jaccard_similarity],
   )
   ```

4. 평가할 모델을 정의합니다:

   ```python lines
   @weave.op
   def my_model(input: str) -> str:
       ...
   ```

5. 평가를 실행합니다:

   ```python lines
    async def run_all():
        await evaluation.evaluate(model_vanilla)
        await evaluation.evaluate(model_humanlike)
        await evaluation.evaluate(model_messy)

   asyncio.run(run_all())
   ```

6. 리더보드를 생성합니다:

   ```python lines
   spec = leaderboard.Leaderboard(
       name="My Leaderboard",
       description="Evaluating models on X task",
       columns=[
           leaderboard.LeaderboardColumn(
               evaluation_object_ref=get_ref(evaluation).uri(),
               scorer_name="jaccard_similarity",
               summary_metric_path="mean",
           )
       ]
   )
   ```

7. 리더보드를 게시합니다.

   ```python lines
   weave.publish(spec)
   ```

8. 결과를 조회합니다:

   ```python lines
   results = leaderboard.get_leaderboard_results(spec, client)
   print(results)
   ```

<div id="end-to-end-python-example">
  ## End-to-End Python 예제
</div>

다음 예제는 Weave Evaluations를 사용해 커스텀 메트릭으로 공유 데이터셋에서 세 개의 요약 모델을 비교하는 리더보드를 생성합니다. 이 예제에서는 작은 벤치마크를 만들고, 각 모델을 평가한 뒤 [Jaccard similarity](https://www.learndatasci.com/glossary/jaccard-similarity/)로 각 모델에 점수를 매기고, 결과를 Weave 리더보드에 게시합니다.

```python lines
import weave
from weave.flow import leaderboard
from weave.trace.ref_util import get_ref
import asyncio

client = weave.init("leaderboard-demo")

dataset = [
    {
        "input": "Weave is a tool for building interactive LLM apps. It offers observability, trace inspection, and versioning.",
        "target": "Weave helps developers build and observe LLM applications."
    },
    {
        "input": "The OpenAI GPT-4o model can process text, audio, and vision inputs, making it a multimodal powerhouse.",
        "target": "GPT-4o is a multimodal model for text, audio, and images."
    },
    {
        "input": "The W&B team recently added native support for agents and evaluations in Weave.",
        "target": "W&B added agents and evals to Weave."
    }
]

@weave.op
def jaccard_similarity(target: str, output: str) -> float:
    target_tokens = set(target.lower().split())
    output_tokens = set(output.lower().split())
    intersection = len(target_tokens & output_tokens)
    union = len(target_tokens | output_tokens)
    return intersection / union if union else 0.0

evaluation = weave.Evaluation(
    name="Summarization Quality",
    dataset=dataset,
    scorers=[jaccard_similarity],
)

@weave.op
def model_vanilla(input: str) -> str:
    return input[:50]

@weave.op
def model_humanlike(input: str) -> str:
    if "Weave" in input:
        return "Weave helps developers build and observe LLM applications."
    elif "GPT-4o" in input:
        return "GPT-4o supports text, audio, and vision input."
    else:
        return "W&B added agent support to Weave."

@weave.op
def model_messy(input: str) -> str:
    return "Summarizer summarize models model input text LLMs."

async def run_all():
    await evaluation.evaluate(model_vanilla)
    await evaluation.evaluate(model_humanlike)
    await evaluation.evaluate(model_messy)

asyncio.run(run_all())

spec = leaderboard.Leaderboard(
    name="Summarization Model Comparison",
    description="Evaluate summarizer models using Jaccard similarity on 3 short samples.",
    columns=[
        leaderboard.LeaderboardColumn(
            evaluation_object_ref=get_ref(evaluation).uri(),
            scorer_name="jaccard_similarity",
            summary_metric_path="mean",
        )
    ]
)

weave.publish(spec)

results = leaderboard.get_leaderboard_results(spec, client)
print(results)
```


<div id="view-and-interpret-the-leaderboard">
  ### 리더보드 보기 및 해석하기
</div>

스크립트 실행이 완료되면 리더보드를 확인합니다:

1. **Weave UI**에서 **Leaders** 탭으로 이동합니다. 보이지 않으면 **More**를 클릭한 다음 **Leaders**를 선택합니다.
2. 리더보드 이름(예: `Summarization Model Comparison`)을 클릭합니다.

리더보드 테이블에서 각 행은 하나의 모델(`model_humanlike`, `model_vanilla`, `model_messy`)을 나타냅니다. `mean` 열에는 해당 모델의 출력과 기준 요약(reference summaries) 간의 평균 Jaccard similarity가 표시됩니다.

<Frame>
![Weave UI의 리더보드 예시](/weave/guides/core-types/imgs/leaderboard-example.png)
</Frame>

이 예시에서는:

- `model_humanlike`이(가) 약 46%의 겹치는 비율(overlap)로 가장 좋은 성능을 보입니다.
- `model_vanilla`(단순 잘라내기 방식, naive truncation)는 약 21%를 기록합니다.
- `model_messy`는 의도적으로 성능이 낮게 설계한 모델로, 약 2%에 그칩니다.