---
title: "util"
description: "weave.trace.util에 대한 Python SDK 참조"
---

import { SourceLink } from '/snippets/ko/_includes/source-link.mdx';


<div id="api-overview">
  # API 개요
</div>

---

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L100" />

## <kbd>class</kbd> `ContextAwareThread`

호출자(caller)의 컨텍스트로 함수를 실행하는 스레드입니다.

이 클래스는 `threading.Thread`를 그대로 대체할 수 있는 구현으로, 스레드 내부에서도 호출이 예상대로 동작하도록 보장합니다. Weave는 특정 `contextvars`가 설정되어 있어야 합니다(`call_context.py` 참고). 하지만 새로 생성된 스레드는 부모의 컨텍스트를 자동으로 복사하지 않기 때문에 호출 컨텍스트가 유실될 수 있으며, 이는 바람직하지 않습니다. 이 클래스는 `contextvar` 복사를 자동화하여, 사용자가 기대하는 것처럼 이 스레드를 사용하기만 하면 “그냥 동작”하도록 해 줍니다.

이 클래스를 사용하지 않고도, 대신 다음과 같이 작성해서 동일한 효과를 얻을 수 있습니다:

```python
def run_with_context(func, *args, **kwargs):
     context = copy_context()
     def wrapper():
         context.run(func, *args, **kwargs)
     return wrapper

thread = threading.Thread(target=run_with_context(your_func, *args, **kwargs))
thread.start()
```

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L124" />


### <kbd>method</kbd> `__init__`

```python
__init__(*args: 'Any', **kwargs: 'Any') → None
```

***


#### <kbd>property</kbd> daemon

이 스레드가 데몬 스레드인지 여부를 나타내는 불리언 값입니다. 

이 속성은 `start()`가 호출되기 전에 설정해야 하며, 그렇지 않으면 `RuntimeError`가 발생합니다. 초깃값은 이 스레드를 생성한 스레드로부터 상속됩니다. 메인 스레드는 데몬 스레드가 아니므로, 메인 스레드에서 생성된 모든 스레드의 기본값은 `daemon = False`입니다. 

데몬 스레드만 남았을 때 전체 Python 프로그램이 종료됩니다. 

---

#### <kbd>property</kbd> ident

이 스레드의 식별자이며, 스레드가 아직 시작되지 않았다면 None입니다. 

이 값은 0이 아닌 정수입니다. `get_ident()` 함수를 참고하세요. 스레드가 종료되고 다른 스레드가 생성될 때 스레드 식별자는 재사용될 수 있습니다. 스레드가 종료된 이후에도 이 식별자는 계속 사용할 수 있습니다. 

---

#### <kbd>property</kbd> name

식별에만 사용되는 문자열입니다. 

별도의 의미는 없습니다. 여러 스레드에 동일한 name을 지정해도 됩니다. 초기 name은 생성자에서 설정됩니다. 

---

#### <kbd>property</kbd> native_id

이 스레드의 네이티브 정수 스레드 ID이며, 스레드가 아직 시작되지 않았다면 None입니다. 

이 값은 음수가 아닌 정수입니다. `get_native_id()` 함수를 참조하세요. 커널이 보고하는 스레드 ID를 나타냅니다. 

---

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L128" />

### <kbd>method</kbd> `run`

```python
run() → None
```

***

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L40" />


## <kbd>class</kbd> `ContextAwareThreadPoolExecutor`

호출자(caller)의 컨텍스트를 사용해 함수를 실행하는 ThreadPoolExecutor입니다.

이 클래스는 concurrent.futures.ThreadPoolExecutor를 그대로 교체해 사용할 수 있는(drop-in replacement) 클래스로, executor 내부에서 Weave 호출이 예상대로 동작하도록 보장합니다. Weave는 특정 contextvars가 설정되어 있어야 동작합니다(call&#95;context.py 참조). 하지만 새 스레드는 부모로부터 컨텍스트를 자동으로 복사하지 않기 때문에, 이로 인해 call context가 손실될 수 있습니다. 이는 바람직하지 않습니다. 이 클래스는 contextvar 복사를 자동화하여, 이 executor를 사용할 때 사용자가 기대하는 대로 &quot;그냥 잘 동작&quot;하도록 해 줍니다.

이 클래스를 사용하지 않고도, 대신 다음과 같이 작성하여 동일한 효과를 얻을 수 있습니다:

```python
with concurrent.futures.ThreadPoolExecutor() as executor:
     contexts = [copy_context() for _ in range(len(vals))]

     def _wrapped_fn(*args):
         return contexts.pop().run(fn, *args)

     executor.map(_wrapped_fn, vals)
```

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L63" />


### <kbd>method</kbd> `__init__`

```python
__init__(*args: 'Any', **kwargs: 'Any') → None
```

***

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L72" />


### <kbd>method</kbd> `map`

```python
map(
    fn: 'Callable',
    *iterables: 'Iterable[Any]',
    timeout: 'float | None' = None,
    chunksize: 'int' = 1
) → Iterator
```

***

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L68" />


### <kbd>method</kbd> `submit`

```python
submit(fn: 'Callable', *args: 'Any', **kwargs: 'Any') → Any
```

***

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L159" />


### <kbd>function</kbd> `deprecated`

```python
deprecated(new_name: 'str') → Callable[[Callable[, Any]], Callable[, Any]]
```

함수를 사용 중단(deprecated)으로 표시하고, 사용자를 `new_name`으로 리디렉션하는 데코레이터입니다.

***

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L132" />


### <kbd>함수</kbd> `is_colab`

```python
is_colab()
```

***

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L141" />


### <kbd>function</kbd> `is_notebook`

```python
is_notebook() → bool
```

***

<SourceLink url="https://github.com/wandb/weave/blob/v0.52.24/weave/trace/util.py#L16" />


### <kbd>function</kbd> `log_once`

```python
log_once(log_method: 'Callable[[str], None]', message: 'str') → None
```

동일한 유형의 메시지는 한 번만 로깅하고, 이후에는 기록하지 않습니다. 이는 로그를 과도하게 누적시키지 않으면서 오류를 사용자에게 알릴 때 유용합니다.

이는 같은 오류 메시지가 여러 번 발생할 수 있는 경우에 주로 유용합니다. 예를 들어, 어떤 op가 저장에 실패하면 해당 op가 호출될 때마다 같은 실패가 발생할 가능성이 큽니다. 또는 패치된 이터레이터에 오류가 있으면 결과를 순회(iterate)할 때마다 같은 오류가 발생할 수 있습니다. 이 함수를 사용하면 로그가 가득 차지 않도록 하면서도 사용자에게 오류를 알릴 수 있습니다.

**Args:**

* <b>`log_method`</b>: 메시지를 로깅하는 데 사용할 메서드입니다. 문자열 인자를 하나 받아야 합니다.
* <b>`message`</b>: 로깅할 메시지입니다.
  **Example:**

```python
log_once(logger.error, "Failed to save op")
```
