---
title: Launch 작업 생성하기
---

<Card title="Colab에서 실행해 보기" href="https://colab.research.google.com/drive/1wX0OSVxZJDHRsZaOaOEDx-lLUrO1hHgP" icon="python" />

Launch job은 W&amp;B run을 재현하기 위한 설계도입니다. job은 워크로드를 실행하는 데 필요한 소스 코드, 종속성, 입력을 캡처하는 W&amp;B Artifacts입니다.

`wandb launch` 명령어로 job을 생성하고 실행합니다.

<Note>
  작업을 실행하지 않고 job만 생성하려면 `wandb job create` 명령어를 사용하세요. 자세한 내용은 [명령어 레퍼런스 문서](/ko/models/ref/cli/wandb-job/wandb-job-create)를 참고하세요.
</Note>

<div id="git-jobs">
  ## Git 잡
</div>

코드와 기타 추적되는 자산을 원격 Git 리포지토리의 특정 커밋, 브랜치 또는 태그에서 W&amp;B Launch를 사용해 클론하는 Git 기반 잡을 만들 수 있습니다. 코드가 포함된 URI를 지정하려면 `--uri` 또는 `-u` 플래그를 사용하고, 선택적으로 `--build-context` 플래그를 사용해 하위 디렉터리를 지정할 수 있습니다.

다음 명령으로 Git 리포지토리에서 “hello world” 잡을 실행합니다:

```bash
wandb launch --uri "https://github.com/wandb/launch-jobs.git" --build-context jobs/hello_world --dockerfile Dockerfile.wandb --project "hello-world" --job-name "hello-world" --entry-point "python job.py"
```

이 명령은 다음을 수행합니다:

1. [W&amp;B Launch jobs 저장소](https://github.com/wandb/launch-jobs)를 임시 디렉터리로 클론합니다.
2. **hello** 프로젝트에 **hello-world-git**이라는 이름의 잡을 생성합니다. 이 잡은 해당 저장소의 기본 브랜치 최신 커밋과 연결됩니다.
3. `jobs/hello_world` 디렉터리와 `Dockerfile.wandb`를 사용해 컨테이너 이미지를 빌드합니다.
4. 컨테이너를 시작하고 `python job.py`를 실행합니다.

특정 브랜치나 커밋 해시로부터 잡을 빌드하려면 `-g`, `--git-hash` 인자를 추가하십시오. 전체 인자 목록을 보려면 `wandb launch --help`를 실행하십시오.

<div id="remote-url-format">
  ### 원격 URL 형식
</div>

Launch 잡과 연결된 git 리모트는 HTTPS 또는 SSH URL일 수 있습니다. URL 유형에 따라 잡 소스 코드를 가져올 때 사용되는 프로토콜이 결정됩니다.

| 원격 URL 유형 | URL 형식 | 접근 및 인증 요건 |
| ----------| ------------------- | ------------------------------------------ |
| https      | `https://github.com/organization/repository.git`  | git 리모트에 인증하기 위한 사용자 이름과 비밀번호 |
| ssh        | `git@github.com:organization/repository.git` | git 리모트에 인증하기 위한 SSH 키 |

구체적인 URL 형식은 호스팅 제공자에 따라 달라집니다. `wandb launch --uri`로 생성된 잡은 제공된 `--uri`에 지정된 전송 프로토콜을 사용합니다.

<div id="code-artifact-jobs">
  ## 코드 아티팩트 잡
</div>

잡은 W&amp;B Artifact에 저장된 모든 소스 코드로부터 생성할 수 있습니다. 로컬 디렉터리를 `--uri` 또는 `-u` 인수로 지정해 새 코드 아티팩트와 잡을 생성하세요.

먼저, 빈 디렉터리를 만들고 아래 내용이 담긴 `main.py`라는 이름의 Python 스크립트를 추가하세요:

```python
import wandb

with wandb.init() as run:
    run.log({"metric": 0.5})
```

다음 내용을 담은 `requirements.txt` 파일을 추가하세요:

```txt
wandb>=0.17.1
```

다음 명령으로 디렉터리를 코드 아티팩트로 로깅하고 작업을 실행하세요:

```bash
wandb launch --uri . --job-name hello-world-code --project launch-quickstart --entry-point "python main.py"
```

앞의 명령어는 다음을 수행합니다:

1. 현재 디렉터리를 `hello-world-code`라는 이름의 코드 아티팩트로 로깅합니다.
2. `launch-quickstart` 프로젝트에 `hello-world-code`라는 이름의 job을 생성합니다.
3. 현재 디렉터리와 Launch의 기본 Dockerfile을 사용해 컨테이너 이미지를 빌드합니다. 기본 Dockerfile은 `requirements.txt`에 있는 항목을 설치하고 엔트리포인트를 `python main.py`로 설정합니다.

<div id="image-jobs">
  ## 이미지 job
</div>

또는 미리 만들어진 Docker 이미지에서 job을 생성할 수도 있습니다. 이는 이미 ML 코드용 빌드 시스템이 갖춰져 있거나, job에 사용할 코드나 요구 사항은 변경할 예정이 없지만 하이퍼파라미터나 다른 인프라 규모를 실험해 보고 싶을 때 유용합니다.

이미지는 Docker 레지스트리에서 pull 한 뒤 지정된 엔트리포인트로 실행되며, 엔트리포인트가 지정되지 않은 경우 기본 엔트리포인트로 실행됩니다. Docker 이미지에서 job을 생성하고 실행하려면 `--docker-image` 옵션에 전체 이미지 태그를 지정하세요.

미리 만들어진 이미지에서 간단한 job을 실행하려면 다음 명령을 사용하세요:

```bash
wandb launch --docker-image "wandb/job_hello_world:main" --project "hello-world"           
```

<div id="automatic-job-creation">
  ## Automatic job creation
</div>

W&amp;B는 Launch로 생성되지 않은 run이라도 소스 코드 추적이 활성화된 모든 run에 대해 자동으로 잡을 생성하고 추적합니다. 다음 세 가지 조건 중 하나라도 만족하면 해당 run은 소스 코드가 추적되는 것으로 간주됩니다:

* run에 연결된 git remote와 커밋 해시가 있는 경우
* run이 코드를 아티팩트로 로깅한 경우. [`Run.log_code`](/ko/models/ref/python/experiments/run#log_code)를 참고하세요.
* run이 `WANDB_DOCKER` 환경 변수가 이미지 태그로 설정된 Docker 컨테이너에서 실행된 경우

Launch 잡이 W&amp;B run에 의해 자동으로 생성된 경우, Git remote URL은 로컬 git 리포지토리에서 자동으로 추론됩니다.

<div id="launch-job-names">
  ### Launch 잡 이름
</div>

기본적으로 W&amp;B는 자동으로 잡 이름을 생성합니다. 잡이 어떻게 생성되었는지(GitHub, 코드 아티팩트 또는 Docker 이미지)에 따라 이름이 달라집니다. 또는 환경 변수를 사용하거나 W&amp;B Python SDK를 사용해서 Launch 잡의 이름을 직접 지정할 수 있습니다.

다음 표는 잡 소스에 따라 기본적으로 사용되는 잡 이름 규칙을 설명합니다:

| Source        | Naming convention                       |
| ------------- | --------------------------------------- |
| GitHub        | `job-<git-remote-url>-<path-to-script>` |
| Code artifact | `job-<code-artifact-name>`              |
| Docker image  | `job-<image-name>`                      |

W&amp;B 환경 변수 또는 W&amp;B Python SDK로 잡 이름 지정하기

<Tabs>
  <Tab title="Environment variable">
    `WANDB_JOB_NAME` 환경 변수를 원하는 잡 이름으로 설정합니다. 예를 들어:

    ```bash
    WANDB_JOB_NAME=awesome-job-name
    ```
  </Tab>

  <Tab title="W&B Python SDK">
    `wandb.Settings`로 잡 이름을 정의한 다음, 이 객체를 `wandb.init`으로 W&amp;B를 초기화할 때 전달합니다. 예를 들어:

    ```python
    settings = wandb.Settings(job_name="my-job-name")
    wandb.init(settings=settings)
    ```
  </Tab>
</Tabs>

<Note>
  Docker 이미지 잡의 경우, 버전 별칭이 자동으로 해당 잡의 별칭으로 추가됩니다.
</Note>

<div id="containerization">
  ## 컨테이너화
</div>

Job은 컨테이너에서 실행됩니다. Image Job은 미리 빌드된 Docker 이미지를 사용하고, Git 및 코드 아티팩트 Job은 별도의 컨테이너 빌드 단계가 필요합니다.

Job의 컨테이너화 방식은 `wandb launch` 명령의 매개변수와 Job 소스 코드 내의 파일을 통해 사용자 정의할 수 있습니다.

<div id="build-context">
  ### 빌드 컨텍스트
</div>

‘빌드 컨텍스트’라는 용어는 컨테이너 이미지를 빌드하기 위해 Docker 데몬으로 전송되는 파일 및 디렉터리 트리를 의미합니다. 기본적으로 Launch는 작업 소스 코드의 루트 디렉터리를 빌드 컨텍스트로 사용합니다. 하위 디렉터리를 빌드 컨텍스트로 지정하려면 작업을 생성하고 실행할 때 `wandb launch`의 `--build-context` 인수를 사용합니다.

<Note>
  `--build-context` 인수는 여러 프로젝트를 포함하는 모노레포를 참조하는 Git 작업을 다룰 때 특히 유용합니다. 하위 디렉터리를 빌드 컨텍스트로 지정하면 모노레포 내 특정 프로젝트에 대한 컨테이너 이미지를 빌드할 수 있습니다.

  공식 W&amp;B Launch jobs 저장소에서 `--build-context` 인수를 사용하는 방법에 대한 예시는 [위의 예시](#git-jobs)를 참고하세요.
</Note>

<div id="dockerfile">
  ### Dockerfile
</div>

Dockerfile은 Docker 이미지를 빌드하기 위한 지시사항을 담고 있는 텍스트 파일입니다. 기본적으로 Launch는 `requirements.txt` 파일을 설치하는 기본 Dockerfile을 사용합니다. 커스텀 Dockerfile을 사용하려면 `wandb launch`의 `--dockerfile` 인자를 사용해 해당 파일의 경로를 지정합니다.

Dockerfile 경로는 빌드 컨텍스트를 기준으로 상대 경로로 지정됩니다. 예를 들어 빌드 컨텍스트가 `jobs/hello_world`이고 Dockerfile이 `jobs/hello_world` 디렉터리에 위치해 있다면, `--dockerfile` 인자는 `Dockerfile.wandb`로 설정해야 합니다. 공식 W&amp;B Launch jobs 리포지토리에서 `--dockerfile` 인자 사용 예시는 [위 예시](#git-jobs)를 참고하십시오.

<div id="requirements-file">
  ### Requirements 파일
</div>

커스텀 Dockerfile을 제공하지 않은 경우 Launch는 빌드 컨텍스트에서 설치할 Python 의존성을 찾습니다. 빌드 컨텍스트 루트에 `requirements.txt` 파일이 있으면 Launch는 해당 파일에 나열된 의존성을 설치합니다. 그렇지 않고 `pyproject.toml` 파일이 있는 경우 Launch는 `project.dependencies` 섹션에 정의된 의존성을 설치합니다.