---
description: 머신 러닝 실험에서 플롯을 생성하고 추적합니다.
title: 실험에서 플롯 생성 및 추적
---

`wandb.plot`의 메서드를 사용하면, 훈련 과정에서 시간에 따라 변하는 차트를 포함해 `wandb.Run.log()`을 사용하여 차트를 추적할 수 있습니다. W&amp;B의 커스텀 차트 프레임워크에 대해 더 알아보려면 [custom charts walkthrough](/ko/models/app/features/custom-charts/walkthrough/)를 확인하세요.

<div id="basic-charts">
  ### 기본 차트
</div>

이러한 간단한 차트는 메트릭과 결과를 쉽게 시각화할 수 있도록 해 줍니다.

<Tabs>
  <Tab title="선">
    임의의 축 위에 순서대로 연결된 점들로 이루어진 사용자 정의 선형 플롯을 로깅합니다.

    ```python
    import wandb

    with wandb.init() as run:
        data = [[x, y] for (x, y) in zip(x_values, y_values)]
        table = wandb.Table(data=data, columns=["x", "y"])
        run.log(
            {
                "my_custom_plot_id": wandb.plot.line(
                    table, "x", "y", title="Custom Y vs X Line Plot"
                )
            }
        )
    ```

    이 기능을 사용하면 임의의 두 차원에 대해 곡선을 로깅할 수 있습니다. 두 개의 값 리스트를 서로를 x축과 y축으로 해서 플로팅하는 경우, 두 리스트의 값 개수가 정확히 일치해야 합니다. 예를 들어, 각 점에는 반드시 x와 y가 모두 있어야 합니다.

    <Frame>
      <img src="/images/track/line_plot.png" alt="사용자 지정 선형 플롯" />
    </Frame>

    [앱에서 보기](https://wandb.ai/wandb/plots/reports/Custom-Line-Plots--VmlldzoyNjk5NTA)

    [코드 실행](https://tiny.cc/custom-charts)
  </Tab>

  <Tab title="산점도">
    임의의 두 축 x와 y 위의 (x, y) 점 목록으로 이루어진 커스텀 산점도를 로깅합니다.

    ```python
    import wandb

    with wandb.init() as run:
        data = [[x, y] for (x, y) in zip(class_x_scores, class_y_scores)]
        table = wandb.Table(data=data, columns=["class_x", "class_y"])
        run.log({"my_custom_id": wandb.plot.scatter(table, "class_x", "class_y")})
    ```

    이를 사용해 임의의 두 차원에 산점도 포인트를 기록할 수 있습니다. 두 개의 값 리스트를 서로에 대해 플로팅할 때는, 각 리스트에 포함된 값의 개수가 정확히 일치해야 합니다. 예를 들어 각 점에는 x와 y가 모두 있어야 합니다.

    <Frame>
      <img src="/images/track/demo_scatter_plot.png" alt="사용자 지정 산점도" />
    </Frame>

    [앱에서 보기](https://wandb.ai/wandb/plots/reports/Custom-Scatter-Plots--VmlldzoyNjk5NDQ)

    [코드 실행하기](https://tiny.cc/custom-charts)
  </Tab>

  <Tab title="막대 차트">
    레이블이 있는 값 목록을 막대로 표시하는 사용자 지정 막대 차트를 몇 줄의 코드만으로 로깅하세요:

    ```python
    import wandb

    with wandb.init() as run:
        data = [[label, val] for (label, val) in zip(labels, values)]
        table = wandb.Table(data=data, columns=["label", "value"])
        run.log(
            {
            "my_bar_chart_id": wandb.plot.bar(
                table, "label", "value", title="Custom Bar Chart"
            )
        }
    )
    ```

    이것을 사용해 임의의 막대 차트를 로깅할 수 있습니다. 목록에 있는 레이블 수와 값의 수는 정확히 일치해야 합니다. 각 데이터 포인트에는 둘 다가 있어야 합니다.

    <Frame>
      <img src="/images/track/basic_charts_bar.png" alt="사용자 정의 막대 차트" />
    </Frame>

    [앱에서 보기](https://wandb.ai/wandb/plots/reports/Custom-Bar-Charts--VmlldzoyNzExNzk)

    [코드 실행](https://tiny.cc/custom-charts)
  </Tab>

  <Tab title="히스토그램">
    값 목록을 발생 횟수/빈도에 따라 구간(bin)으로 나누는 사용자 지정 히스토그램을 몇 줄의 코드만으로 바로 로깅할 수 있습니다. 예를 들어 예측 신뢰도 점수 목록(`scores`)이 있고, 이들의 분포를 시각화하고 싶다고 가정해 보겠습니다:

    ```python
    import wandb

    with wandb.init() as run:
        data = [[s] for s in scores]
        table = wandb.Table(data=data, columns=["scores"])
        run.log({"my_histogram": wandb.plot.histogram(table, "scores", title="Histogram")})
    ```

    이를 사용해 임의의 히스토그램을 로깅할 수 있습니다. `data`는 행과 열로 이루어진 2D 배열을 지원하기 위한 리스트의 리스트(중첩 리스트)라는 점에 유의하세요.

    <Frame>
      <img src="/images/track/demo_custom_chart_histogram.png" alt="사용자 정의 히스토그램" />
    </Frame>

    [앱에서 보기](https://wandb.ai/wandb/plots/reports/Custom-Histograms--VmlldzoyNzE0NzM)

    [코드 실행하기](https://tiny.cc/custom-charts)
  </Tab>

  <Tab title="다중 선 그래프">
    여러 개의 선 또는 서로 다른 여러 x-y 좌표 쌍 목록을 하나의 공통 x-y 축에 함께 그립니다:

    ```python
    import wandb
    with wandb.init() as run:
        run.log(
            {
                "my_custom_id": wandb.plot.line_series(
                    xs=[0, 1, 2, 3, 4],
                    ys=[[10, 20, 30, 40, 50], [0.5, 11, 72, 3, 41]],
                keys=["metric Y", "metric Z"],
                title="Two Random Metrics",
                xname="x units",
            )
        }
    )
    ```

    x와 y 포인트의 개수는 반드시 정확히 일치해야 합니다. 여러 개의 y 값 리스트에 대응하도록 하나의 x 값 리스트를 제공하거나, 각 y 값 리스트마다 별도의 x 값 리스트를 제공할 수 있습니다.

    <Frame>
      <img src="/images/track/basic_charts_histogram.png" alt="Multi-line plot" />
    </Frame>

    [앱에서 보기](https://wandb.ai/wandb/plots/reports/Custom-Multi-Line-Plots--VmlldzozOTMwMjU)
  </Tab>
</Tabs>

<div id="model-evaluation-charts">
  ### 모델 평가 차트
</div>

이 미리 정의된 차트들은 `wandb.plot()` 메서드를 내장하고 있어 스크립트에서 차트를 바로 로깅하고, UI에서 정확히 원하는 정보를 빠르게 확인할 수 있습니다.

<Tabs>
  <Tab title="정밀도-재현율 곡선">
    한 줄로 [Precision-Recall 커브](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve)를 만듭니다:

    ```python
    import wandb
    with wandb.init() as run:
        # ground_truth는 실제 레이블 목록이고, predictions는 예측 점수 목록입니다
        # 예: ground_truth = [0, 1, 1, 0], predictions = [0.1, 0.4, 0.35, 0.8]
        ground_truth = [0, 1, 1, 0]
        predictions = [0.1, 0.4, 0.35, 0.8]
        run.log({"pr": wandb.plot.pr_curve(ground_truth, predictions)})
    ```

    코드에서 다음에 접근할 수 있을 때마다 이 값을 로깅할 수 있습니다:

    * 예제 집합에 대한 모델의 예측 점수(`predictions`)
    * 해당 예제들의 정답 레이블(`ground_truth`)
    * (선택 사항) 레이블 인덱스 0이 cat, 1이 dog, 2가 bird 등을 의미하는 경우의 레이블/클래스 이름 목록(`labels=["cat", "dog", "bird"...]`)
    * (선택 사항) 플롯에서 시각화할 레이블의 부분 집합(리스트 형식 그대로)

    <Frame>
      <img src="/images/track/model_eval_charts_precision_recall.png" alt="정밀도-재현율 곡선" />
    </Frame>

    [앱에서 보기](https://wandb.ai/wandb/plots/reports/Plot-Precision-Recall-Curves--VmlldzoyNjk1ODY)

    [코드 실행](https://colab.research.google.com/drive/1mS8ogA3LcZWOXchfJoMrboW3opY1A8BY?usp=sharing)
  </Tab>

  <Tab title="ROC 곡선">
    한 줄짜리 코드로 [ROC 곡선](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve)을 생성합니다:

    ```python
    import wandb

    with wandb.init() as run:
        # ground_truth는 실제 레이블 목록이고, predictions는 예측 점수 목록입니다
        # 예: ground_truth = [0, 1, 1, 0], predictions = [0.1, 0.4, 0.35, 0.8]
        ground_truth = [0, 1, 1, 0]
        predictions = [0.1, 0.4, 0.35, 0.8]
        run.log({"roc": wandb.plot.roc_curve(ground_truth, predictions)})
    ```

    코드에서 다음 항목에 접근할 수 있을 때마다 이를 로깅할 수 있습니다:

    * 예시 집합에 대한 모델의 예측 점수(`predictions`)
    * 해당 예시에 대한 실제 정답 레이블(`ground_truth`)
    * (선택 사항) 레이블 인덱스 0이 cat, 1이 dog, 2가 bird 등을 의미하는 경우의 레이블/클래스 이름 목록(`labels=["cat", "dog", "bird"...]`)
    * (선택 사항) 플롯에서 시각화할 이 레이블들 중 일부로 구성된 하위 집합(리스트 형식 유지)

    <Frame>
      <img src="/images/track/demo_custom_chart_roc_curve.png" alt="ROC curve" />
    </Frame>

    [앱에서 보기](https://wandb.ai/wandb/plots/reports/Plot-ROC-Curves--VmlldzoyNjk3MDE)

    [코드 실행하기](https://colab.research.google.com/github/wandb/examples/blob/master/colabs/wandb-log/Plot_ROC_Curves_with_W%26B.ipynb)
  </Tab>

  <Tab title="혼동 행렬">
    한 줄짜리 코드로 다중 클래스 [confusion matrix](https://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html)를 생성합니다:

    ```python
    import wandb

    cm = wandb.plot.confusion_matrix(
        y_true=ground_truth, preds=predictions, class_names=class_names
    )

    with wandb.init() as run:
        run.log({"conf_mat": cm})
    ```

    코드에서 다음에 접근할 수 있는 위치라면 어디에서든 이 정보를 로깅할 수 있습니다:

    * 일련의 예제에 대한 모델의 예측 레이블(`preds`) 또는 정규화된 확률 점수(`probs`). 확률 텐서는 (예제 개수, 클래스 개수) 형태여야 합니다. 확률이나 예측값 중 하나만 제공할 수 있으며, 둘 다 동시에 제공할 수는 없습니다.
    * 해당 예제들에 대한 정답 레이블(`y_true`)
    * 문자열로 된 전체 레이블/클래스 이름 목록인 `class_names`. 예시: 인덱스 0이 `cat`, 1이 `dog`, 2가 `bird`인 경우 `class_names=["cat", "dog", "bird"]`.

    <Frame>
      <img src="/images/experiments/confusion_matrix.png" alt="혼동 행렬" />
    </Frame>

    ​[앱에서 보기](https://wandb.ai/wandb/plots/reports/Confusion-Matrix--VmlldzozMDg1NTM)​

    ​[코드 실행](https://colab.research.google.com/github/wandb/examples/blob/master/colabs/wandb-log/Log_a_Confusion_Matrix_with_W%26B.ipynb)
  </Tab>
</Tabs>

<div id="interactive-custom-charts">
  ### 대화형 커스텀 차트
</div>

완전히 원하는 대로 커스터마이징하려면 기본 제공 [Custom Chart 프리셋](/ko/models/app/features/custom-charts/walkthrough/)을 수정하거나 새 프리셋을 만든 뒤 차트를 저장하세요. 스크립트에서 해당 커스텀 프리셋으로 직접 데이터를 로깅하려면 차트 ID를 사용하세요.

```python
import wandb
# 플롯할 열이 포함된 테이블 생성
table = wandb.Table(data=data, columns=["step", "height"])

# 테이블의 열을 차트의 필드에 매핑
fields = {"x": "step", "value": "height"}

# 테이블을 사용하여 새 커스텀 차트 프리셋 채우기
# 저장된 차트 프리셋을 사용하려면 vega_spec_name을 변경하세요
# 제목을 수정하려면 string_fields를 변경하세요
my_custom_chart = wandb.plot_table(
    vega_spec_name="carey/new_chart",
    data_table=table,
    fields=fields,
    string_fields={"title": "Height Histogram"},
)

with wandb.init() as run:
    # 커스텀 차트 로깅
    run.log({"my_custom_chart": my_custom_chart})
```

[코드를 실행하세요](https://tiny.cc/custom-charts)

<div id="matplotlib-and-plotly-plots">
  ### Matplotlib 및 Plotly 플롯
</div>

`wandb.plot()`를 사용해 W&amp;B [Custom Charts](/ko/models/app/features/custom-charts/walkthrough/)를 만드는 대신, [matplotlib](https://matplotlib.org/) 및 [Plotly](https://plotly.com/)로 생성한 차트를 로그할 수 있습니다.

```python
import wandb
import matplotlib.pyplot as plt

with wandb.init() as run:
    # 간단한 matplotlib 플롯 생성
    plt.figure()
    plt.plot([1, 2, 3, 4])
    plt.ylabel("some interesting numbers")
    
    # W&B에 플롯 기록
    run.log({"chart": plt})
```

`matplotlib` 플롯이나 figure 객체를 `wandb.Run.log()`에 그대로 전달하면 됩니다. 기본적으로 플롯은 [Plotly](https://plot.ly/) 플롯으로 변환됩니다. 플롯을 이미지로 기록하고 싶다면 플롯을 `wandb.Image`에 전달하면 됩니다. Plotly 차트도 직접 전달할 수 있습니다.

<Note>
  &quot;You attempted to log an empty plot&quot; 오류가 발생하는 경우, `fig = plt.figure()`로 플롯과는 별도의 figure를 생성한 다음 `wandb.Run.log()`를 호출할 때 `fig`를 기록하면 됩니다.
</Note>

<div id="log-custom-html-to-wb-tables">
  ### 사용자 정의 HTML을 W&amp;B Tables에 로그하기
</div>

W&amp;B는 Plotly 및 Bokeh에서 생성한 대화형 차트를 HTML로 로그하여 Tables에 추가하는 기능을 제공합니다.

<div id="log-plotly-figures-to-tables-as-html">
  #### Plotly Figure를 HTML로 변환해 Tables에 기록하기
</div>

대화형 Plotly 차트를 HTML로 변환해 wandb Tables에 기록할 수 있습니다.

```python
import wandb
import plotly.express as px

# 새 실행 초기화
with wandb.init(project="log-plotly-fig-tables", name="plotly_html") as run:

    # 테이블 생성
    table = wandb.Table(columns=["plotly_figure"])

    # Plotly 그림 경로 생성
    path_to_plotly_html = "./plotly_figure.html"

    # Plotly 그림 예시
    fig = px.scatter(x=[0, 1, 2, 3, 4], y=[0, 1, 4, 9, 16])

    # Plotly 그림을 HTML로 저장
    # auto_play를 False로 설정하면 애니메이션 Plotly 차트가
    # 테이블에서 자동으로 재생되는 것을 방지
    fig.write_html(path_to_plotly_html, auto_play=False)

    # Plotly 그림을 HTML 파일로 테이블에 추가
    table.add_data(wandb.Html(path_to_plotly_html))

    # 테이블 로깅
    run.log({"test_table": table})
```

<div id="log-bokeh-figures-to-tables-as-html">
  #### Bokeh Figure를 HTML로 Tables에 로깅하기
</div>

대화형 Bokeh 차트를 HTML로 변환하여 wandb Tables에 로깅할 수 있습니다.

```python
from scipy.signal import spectrogram
import holoviews as hv
import panel as pn
from scipy.io import wavfile
import numpy as np
from bokeh.resources import INLINE

hv.extension("bokeh", logo=False)
import wandb


def save_audio_with_bokeh_plot_to_html(audio_path, html_file_name):
    sr, wav_data = wavfile.read(audio_path)
    duration = len(wav_data) / sr
    f, t, sxx = spectrogram(wav_data, sr)
    spec_gram = hv.Image((t, f, np.log10(sxx)), ["Time (s)", "Frequency (hz)"]).opts(
        width=500, height=150, labelled=[]
    )
    audio = pn.pane.Audio(wav_data, sample_rate=sr, name="Audio", throttle=500)
    slider = pn.widgets.FloatSlider(end=duration, visible=False)
    line = hv.VLine(0).opts(color="white")
    slider.jslink(audio, value="time", bidirectional=True)
    slider.jslink(line, value="glyph.location")
    combined = pn.Row(audio, spec_gram * line, slider).save(html_file_name)


html_file_name = "audio_with_plot.html"
audio_path = "hello.wav"
save_audio_with_bokeh_plot_to_html(audio_path, html_file_name)

wandb_html = wandb.Html(html_file_name)

with wandb.init(project="audio_test") as run:
    my_table = wandb.Table(columns=["audio_with_plot"], data=[[wandb_html]])
    run.log({"audio_table": my_table})
```
