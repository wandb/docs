---
description: W&B로 테이블을 기록합니다.
title: 테이블 기록
---

`wandb.Table`을 사용하여 데이터를 기록하고 W&amp;B에서 시각화하거나 조회할 수 있습니다. 이 가이드에서는 다음 내용을 학습합니다:

1. [테이블 생성](./log-tables#create-tables)
2. [데이터 추가](./log-tables#add-data)
3. [데이터 가져오기](./log-tables#retrieve-data)
4. [테이블 저장](./log-tables#save-tables)

<div id="create-tables">
  ## 테이블 생성
</div>

Table을 정의하려면 데이터의 각 행에 대해 확인하고 싶은 열(columns)을 지정합니다. 각 행에는 학습 데이터셋의 단일 아이템, 학습 중의 특정 step이나 epoch, 테스트 아이템에 대해 모델이 수행한 예측, 모델이 생성한 객체 등이 들어갈 수 있습니다. 각 열은 숫자, 텍스트, 불리언(boolean), 이미지, 비디오, 오디오 등과 같은 고정된 타입을 가집니다. 타입을 미리 지정할 필요는 없습니다. 각 열에 이름을 부여하고, 해당 열 인덱스에는 그 타입의 데이터만 전달하면 됩니다. 더 자세한 예시는 [W&amp;B Tables guide](https://wandb.ai/stacey/mnist-viz/reports/Guide-to-W-B-Tables--Vmlldzo2NTAzOTk#1.-how-to-log-a-wandb.table)를 참고하십시오.

`wandb.Table` 생성자는 다음 두 가지 방식 중 하나로 사용할 수 있습니다:

1. **행 리스트(List of Rows):**

   이름이 지정된 열과 데이터 행을 로깅합니다. 예를 들어, 다음 코드 스니펫은 두 개의 행과 세 개의 열을 가진 테이블을 생성합니다:

   ```python
   wandb.Table(columns=["a", "b", "c"], data=[["1a", "1b", "1c"], ["2a", "2b", "2c"]])
   ```

2. **Pandas DataFrame:** `wandb.Table(dataframe=my_df)`를 사용해 DataFrame을 로깅합니다. 열 이름은 DataFrame에서 추출됩니다.

<div id="from-an-existing-array-or-dataframe">
  #### 기존 배열이나 데이터프레임에서
</div>

```python
# 모델이 네 개의 이미지에 대한 예측을 반환했다고 가정합니다
# 다음 필드를 사용할 수 있습니다:
# - 이미지 id
# - wandb.Image()로 래핑된 이미지 픽셀
# - 모델의 예측 레이블
# - 실제 정답 레이블
my_data = [
    [0, wandb.Image("img_0.jpg"), 0, 0],
    [1, wandb.Image("img_1.jpg"), 8, 0],
    [2, wandb.Image("img_2.jpg"), 7, 1],
    [3, wandb.Image("img_3.jpg"), 1, 1],
]

# 해당 열로 wandb.Table()을 생성합니다
columns = ["id", "image", "prediction", "truth"]
test_table = wandb.Table(data=my_data, columns=columns)
```

<div id="add-data">
  ## 데이터 추가
</div>

테이블은 변경 가능한 객체입니다. 스크립트 실행 중에 최대 200,000개 행까지 테이블에 데이터를 계속 추가할 수 있습니다. 테이블에 데이터를 추가하는 방법은 두 가지입니다:

1. **행 추가**: `table.add_data("3a", "3b", "3c")`. 새 행은 리스트로 표현되지 않는다는 점에 유의하세요. 행이 리스트 형태라면, 리스트를 위치 인자로 펼치기 위해 별표 표기법 `*`을 사용하세요: `table.add_data(*my_row_list)`. 행에는 테이블의 열 개수와 동일한 개수의 항목이 포함되어야 합니다.
2. **열 추가**: `table.add_column(name="col_name", data=col_data)`. `col_data`의 길이는 현재 테이블의 행 개수와 같아야 한다는 점에 유의하세요. 여기서 `col_data`는 리스트 또는 NumPy NDArray일 수 있습니다.

<div id="adding-data-incrementally">
  ### 점진적으로 데이터 추가하기
</div>

다음 코드 예제는 W&amp;B 테이블을 점진적으로 생성하고 채우는 방법을 보여 줍니다. 가능한 모든 레이블에 대한 신뢰도 점수를 포함한 미리 정의된 열로 테이블을 정의한 뒤, 추론 중에 행 단위로 데이터를 추가합니다. 또한 [재개한 실행에 테이블 데이터를 점진적으로 추가](#adding-data-to-resumed-runs)할 수도 있습니다.

```python
# 테이블의 열을 정의합니다. 각 레이블에 대한 신뢰도 점수를 포함합니다
columns = ["id", "image", "guess", "truth"]
for digit in range(10):  # 각 숫자(0-9)에 대한 신뢰도 점수 열을 추가합니다
    columns.append(f"score_{digit}")

# 정의된 열로 테이블을 초기화합니다
test_table = wandb.Table(columns=columns)

# 테스트 데이터셋을 순회하며 테이블에 행 단위로 데이터를 추가합니다
# 각 행에는 이미지 ID, 이미지, 예측 레이블, 실제 레이블, 신뢰도 점수가 포함됩니다
for img_id, img in enumerate(mnist_test_data):
    true_label = mnist_test_data_labels[img_id]  # 정답 레이블
    guess_label = my_model.predict(img)  # 예측 레이블
    test_table.add_data(
        img_id, wandb.Image(img), guess_label, true_label
    )  # 테이블에 행 데이터를 추가합니다
```

<div id="adding-data-to-resumed-runs">
  #### 재개한 실행에 데이터 추가하기
</div>

기존 아티팩트에서 테이블을 불러오고, 마지막 행의 데이터를 가져와 업데이트된 지표를 추가함으로써 재개한 실행에서 W&amp;B 테이블을 순차적으로 업데이트할 수 있습니다. 그런 다음 호환성을 위해 테이블을 다시 초기화하고, 업데이트된 버전을 W&amp;B에 다시 기록합니다.

```python
import wandb

# 실행 초기화 
with wandb.init(project="my_project") as run:

    # 아티팩트에서 기존 테이블 로드
    best_checkpt_table = run.use_artifact(table_tag).get(table_name)

    # 재개를 위해 테이블의 마지막 행 데이터 가져오기
    best_iter, best_metric_max, best_metric_min = best_checkpt_table.data[-1]

    # 필요에 따라 최적 메트릭 업데이트

    # 업데이트된 데이터를 테이블에 추가
    best_checkpt_table.add_data(best_iter, best_metric_max, best_metric_min)

    # 호환성 확보를 위해 업데이트된 데이터로 테이블 재초기화
    best_checkpt_table = wandb.Table(
        columns=["col1", "col2", "col3"], data=best_checkpt_table.data
    )

    # 실행 초기화
    with wandb.init() as run:

        # 업데이트된 테이블을 W&B에 로깅
        run.log({table_name: best_checkpt_table})
```

<div id="retrieve-data">
  ## 데이터 가져오기
</div>

데이터가 Table 안에 있으면, 열 단위 또는 행 단위로 액세스할 수 있습니다:

1. **행 이터레이터(Row Iterator)**: 사용자는 `for ndx, row in table.iterrows(): ...`와 같이 Table의 행 이터레이터를 사용해 데이터의 행을 효율적으로 순회할 수 있습니다.
2. **열 가져오기(Get a Column)**: 사용자는 `table.get_column("col_name")`을 사용해서 데이터의 한 열을 가져올 수 있습니다. 편의를 위해, 열을 NumPy NDArray의 기본 타입으로 변환하려면 `convert_to="numpy"`를 인자로 전달할 수 있습니다. 이 기능은 열에 `wandb.Image`와 같은 미디어 타입이 들어 있을 때, 그 내부 데이터에 직접 접근해야 하는 경우에 유용합니다.

<div id="save-tables">
  ## 테이블 저장
</div>

스크립트에서 데이터 테이블(예: 모델 예측 테이블)을 생성한 후, W&amp;B에 저장해서 결과를 실시간으로 시각화하세요.

<div id="log-a-table-to-a-run">
  ### 실행에 테이블 기록하기
</div>

`wandb.Run.log()`을 사용해 다음과 같이 테이블을 실행에 기록합니다:

```python
with wandb.init() as run:
    my_table = wandb.Table(columns=["a", "b"], data=[["1a", "1b"], ["2a", "2b"]])
    run.log({"table_key": my_table})
```

동일한 키에 테이블을 로깅할 때마다 새로운 버전의 테이블이 생성되어 백엔드에 저장됩니다. 이는 동일한 테이블을 여러 학습 단계에 걸쳐 반복해서 로깅하여 시간이 지남에 따라 모델 예측이 어떻게 개선되는지 확인하거나, 동일한 키에만 로깅된다면 서로 다른 실행 간의 테이블을 비교할 수 있음을 의미합니다. 최대 200,000개의 행을 로깅할 수 있습니다.

<Note>
  200,000개 이상의 행을 로깅하려면 다음과 같이 상한을 재정의할 수 있습니다:

  `wandb.Table.MAX_ARTIFACT_ROWS = X`

  그러나 이렇게 하면 UI에서 쿼리가 느려지는 등 성능 문제가 발생할 수 있습니다.
</Note>

<div id="access-tables-programmatically">
  ### 프로그래밍 방식으로 Tables에 액세스하기
</div>

백엔드에서는 Tables가 Artifacts로 저장됩니다. 특정 버전에 액세스하려면 Artifact API를 사용하세요:

```python
with wandb.init() as run:
    my_table = run.use_artifact("run-<run-id>-<table-name>:<tag>").get("<table-name>")
```

Artifacts에 대한 자세한 내용은 Developer Guide의 [Artifacts 장](/ko/models/artifacts/)을 참고하세요.

<div id="visualize-tables">
  ### 테이블 시각화
</div>

이 방식으로 기록한 모든 테이블은 워크스페이스의 실행 페이지와 프로젝트 페이지 모두에 표시됩니다. 자세한 내용은 [테이블 시각화 및 분석](/ko/models/tables/visualize-tables/)을 참조하세요.

<div id="artifact-tables">
  ## Artifact tables
</div>

워크스페이스 대신 실행의 Artifacts 섹션에 테이블을 로그하려면 `artifact.add()`를 사용합니다. 이는 한 번만 로그해 두고 이후 실행에서 재사용하거나 참조하고 싶은 데이터셋이 있을 때 유용합니다.

```python
with wandb.init(project="my_project") as run:
    # 각 의미 있는 단계마다 wandb Artifact 생성
    test_predictions = wandb.Artifact("mnist_test_preds", type="predictions")

    # [위와 같이 예측 데이터를 구성]
    test_table = wandb.Table(data=data, columns=columns)
    test_predictions.add(test_table, "my_test_key")
    run.log_artifact(test_predictions)
```

이미지 데이터와 함께 `artifact.add()`를 사용하는 [자세한 예제는 이 Colab 노트북](https://wandb.me/dsviz-nature-colab)을 참고하고, Artifacts와 Tables를 사용해 [테이블형 데이터를 버전 관리하고 중복 제거하는 방법에 대한 예제는 이 Report](https://wandb.me/TBV-Dedup)를 참고하세요.

<div id="join-artifact-tables">
  ### Artifact 테이블 조인
</div>

로컬에서 생성한 테이블이든 다른 아티팩트에서 가져온 테이블이든 `wandb.JoinedTable(table_1, table_2, join_key)`를 사용해 조인할 수 있습니다.

| Args         | Description                                                                            |
| ------------ | -------------------------------------------------------------------------------------- |
| table&#95;1  | (str, `wandb.Table`, ArtifactEntry) 아티팩트 안의 `wandb.Table` 경로, 테이블 객체, 또는 ArtifactEntry |
| table&#95;2  | (str, `wandb.Table`, ArtifactEntry) 아티팩트 안의 `wandb.Table` 경로, 테이블 객체, 또는 ArtifactEntry |
| join&#95;key | (str, [str, str]) 조인을 수행할 때 사용할 키 또는 키 목록                                              |

이전에 아티팩트 컨텍스트에서 로깅해 둔 두 개의 Table을 조인하려면, 아티팩트에서 해당 Table들을 가져온 다음 조인한 결과로 새 Table을 만듭니다.

예를 들어, 다음 코드 예시는 `'original_songs'`라는 이름의 원본 곡 Table 하나와 같은 곡들의 합성 버전이 들어 있는 `'synth_songs'`라는 다른 Table을 읽는 방법을 보여줍니다. 이 코드는 두 테이블을 `"song_id"` 컬럼을 기준으로 조인하고, 결과 테이블을 새로운 W&amp;B Table로 업로드합니다:

```python
import wandb

with wandb.init(project="my_project") as run:

    # 원본 노래 테이블 가져오기
    orig_songs = run.use_artifact("original_songs:latest")
    orig_table = orig_songs.get("original_samples")

    # 합성 노래 테이블 가져오기
    synth_songs = run.use_artifact("synth_songs:latest")
    synth_table = synth_songs.get("synth_samples")

    # "song_id"를 기준으로 테이블 조인
    join_table = wandb.JoinedTable(orig_table, synth_table, "song_id")
    join_at = wandb.Artifact("synth_summary", "analysis")

    # 아티팩트에 테이블 추가 및 W&B에 로그 기록
    join_at.add(join_table, "synth_explore")
    run.log_artifact(join_at)
```

[이 튜토리얼을 읽어보세요](https://wandb.ai/stacey/cshanty/reports/Whale2Song-W-B-Tables-for-Audio--Vmlldzo4NDI3NzM), 서로 다른 Artifact 객체에 각각 저장된 두 개의 기존 테이블을 결합하는 방법의 예시를 확인할 수 있습니다.
