---
title: 로그 테이블 (Log tables)
description: W&B로 테이블 로그를 남기세요.
---
import { ColabLink } from '/snippets/en/_includes/colab-link.mdx';

<ColabLink url="https://colab.research.google.com/github/wandb/examples/blob/master/colabs/keras/Use_WandbModelCheckpoint_in_your_Keras_workflow.ipynb" />
`wandb.Table`을 사용하여 데이터를 로그하고 W&B에서 시각화 및 쿼리하세요. 이 가이드에서는 다음 방법을 배웁니다:

1. [Tables 생성](./log-tables#create-tables)
2. [데이터 추가](./log-tables#add-data)
3. [데이터 검색](./log-tables#retrieve-data)
4. [Tables 저장](./log-tables#save-tables)

## Tables 생성

Table을 정의하려면 데이터의 각 행에 대해 표시할 열(columns)을 지정합니다. 각 행은 트레이닝 데이터셋의 단일 아이템, 트레이닝 중의 특정 단계 또는 에포크, 테스트 아이템에 대한 모델의 예측값, 모델이 생성한 오브젝트 등이 될 수 있습니다. 각 열은 숫자, 텍스트, 불리언, 이미지, 비디오, 오디오 등의 고정된 타입을 가집니다. 타입을 미리 지정할 필요는 없습니다. 각 열에 이름을 지정하고, 해당 열 인덱스에는 해당 타입의 데이터만 전달하면 됩니다. 더 자세한 예시는 [W&B Tables 가이드](https://wandb.ai/stacey/mnist-viz/reports/Guide-to-W-B-Tables--Vmlldzo2NTAzOTk#1.-how-to-log-a-wandb.table)를 참조하세요.

`wandb.Table` 생성자를 다음 두 가지 방법 중 하나로 사용하세요:

1. **행 목록 (List of Rows):**

   이름이 지정된 열과 데이터 행을 로그합니다. 예를 들어 다음 코드 조각은 2개의 행과 3개의 열이 있는 테이블을 생성합니다:

   ```python
   wandb.Table(columns=["a", "b", "c"], data=[["1a", "1b", "1c"], ["2a", "2b", "2c"]])
   ```


2. **Pandas DataFrame:** `wandb.Table(dataframe=my_df)`를 사용하여 DataFrame을 로그합니다. 열 이름은 DataFrame에서 추출됩니다.

#### 기존 배열 또는 dataframe에서 생성

```python
# 모델이 4개의 이미지에 대해 예측값을 반환했다고 가정합니다.
# 다음과 같은 필드들을 사용할 수 있습니다:
# - 이미지 id
# - wandb.Image()로 래핑된 이미지 픽셀
# - 모델의 예측 레이블
# - 그라운드 트루스 레이블
my_data = [
    [0, wandb.Image("img_0.jpg"), 0, 0],
    [1, wandb.Image("img_1.jpg"), 8, 0],
    [2, wandb.Image("img_2.jpg"), 7, 1],
    [3, wandb.Image("img_3.jpg"), 1, 1],
]

# 해당되는 열과 함께 wandb.Table() 생성
columns = ["id", "image", "prediction", "truth"]
test_table = wandb.Table(data=my_data, columns=columns)
```

## 데이터 추가

Tables는 변경 가능(mutable)합니다. 스크립트가 실행됨에 따라 테이블에 최대 200,000행까지 데이터를 추가할 수 있습니다. 테이블에 데이터를 추가하는 방법은 두 가지입니다:

1. **행 추가 (Add a Row)**: `table.add_data("3a", "3b", "3c")`. 새 행은 리스트로 표현되지 않음에 유의하세요. 행이 리스트 형식인 경우, 별표 표기법 `*`를 사용하여 리스트를 위치 인수로 확장하세요: `table.add_data(*my_row_list)`. 행은 테이블의 열 개수와 동일한 수의 항목을 포함해야 합니다.
2. **열 추가 (Add a Column)**: `table.add_column(name="col_name", data=col_data)`. `col_data`의 길이는 테이블의 현재 행 수와 같아야 합니다. 여기서 `col_data`는 리스트 데이터 또는 NumPy NDArray일 수 있습니다.

### 점진적으로 데이터 추가하기

이 코드 샘플은 W&B 테이블을 점진적으로 생성하고 채우는 방법을 보여줍니다. 모든 가능한 레이블에 대한 신뢰도 점수를 포함하여 미리 정의된 열로 테이블을 정의하고, 추론 중에 행 단위로 데이터를 추가합니다. [Runs를 재개할 때 테이블에 데이터를 점진적으로 추가](#adding-data-to-resumed-runs)할 수도 있습니다.

```python
# 각 레이블에 대한 신뢰도 점수를 포함하여 테이블의 열 정의
columns = ["id", "image", "guess", "truth"]
for digit in range(10):  # 각 숫자(0-9)에 대한 신뢰도 점수 열 추가
    columns.append(f"score_{digit}")

# 정의된 열로 테이블 초기화
test_table = wandb.Table(columns=columns)

# 테스트 데이터셋을 반복하며 테이블에 행 단위로 데이터 추가
# 각 행에는 이미지 ID, 이미지, 예측 레이블, 실제 레이블 및 신뢰도 점수가 포함됨
for img_id, img in enumerate(mnist_test_data):
    true_label = mnist_test_data_labels[img_id]  # 그라운드 트루스 레이블
    guess_label = my_model.predict(img)  # 예측 레이블
    test_table.add_data(
        img_id, wandb.Image(img), guess_label, true_label
    )  # 테이블에 행 데이터 추가
```

#### 재개된 Runs에 데이터 추가하기

Artifact에서 기존 테이블을 로드하고, 마지막 데이터 행을 검색한 뒤, 업데이트된 메트릭을 추가하여 재개된 Runs에서 W&B 테이블을 점진적으로 업데이트할 수 있습니다. 그런 다음 호환성을 위해 테이블을 다시 초기화하고 업데이트된 버전을 다시 W&B에 로그합니다.

```python
import wandb

# run 초기화
with wandb.init(project="my_project") as run:

    # 아티팩트에서 기존 테이블 로드
    best_checkpt_table = run.use_artifact(table_tag).get(table_name)

    # 재개를 위해 테이블에서 마지막 데이터 행 가져오기
    best_iter, best_metric_max, best_metric_min = best_checkpt_table.data[-1]

    # 필요에 따라 최적 메트릭 업데이트

    # 업데이트된 데이터를 테이블에 추가
    best_checkpt_table.add_data(best_iter, best_metric_max, best_metric_min)

    # 호환성을 보장하기 위해 업데이트된 데이터로 테이블 재초기화
    best_checkpt_table = wandb.Table(
        columns=["col1", "col2", "col3"], data=best_checkpt_table.data
    )

    # Run 초기화
    with wandb.init() as run:

        # 업데이트된 테이블을 W&B에 로그
        run.log({table_name: best_checkpt_table})
```

## 데이터 검색

데이터가 Table에 들어가면 열 또는 행별로 엑세스할 수 있습니다:

1. **행 이터레이터 (Row Iterator)**: 사용자는 `for ndx, row in table.iterrows(): ...`와 같은 Table의 행 이터레이터를 사용하여 데이터의 행을 효율적으로 반복할 수 있습니다.
2. **열 가져오기 (Get a Column)**: 사용자는 `table.get_column("col_name")`을 사용하여 데이터 열을 검색할 수 있습니다. 편의를 위해 `convert_to="numpy"`를 전달하여 열을 기본 타입의 NumPy NDArray로 변환할 수 있습니다. 이는 열에 `wandb.Image`와 같은 미디어 타입이 포함되어 있어 기본 데이터에 직접 엑세스하려는 경우에 유용합니다.

## Tables 저장

스크립트에서 데이터 테이블(예: 모델 예측값 테이블)을 생성한 후, 결과를 실시간으로 시각화하기 위해 W&B에 저장하세요.

### Run에 테이블 로그하기

다음과 같이 `wandb.Run.log()`를 사용하여 테이블을 Run에 저장합니다:

```python
with wandb.init() as run:
    my_table = wandb.Table(columns=["a", "b"], data=[["1a", "1b"], ["2a", "2b"]])
    run.log({"table_key": my_table})
```

동일한 키에 테이블이 로그될 때마다 테이블의 새 버전이 생성되어 백엔드에 저장됩니다. 즉, 시간이 지남에 따라 모델 예측이 어떻게 개선되는지 확인하기 위해 여러 트레이닝 단계에 걸쳐 동일한 테이블을 로그하거나, 동일한 키로 로그되는 한 서로 다른 Runs 간의 테이블을 비교할 수 있습니다. 최대 200,000행까지 로그할 수 있습니다.

<Note>
200,000행 이상을 로그하려면 다음을 사용하여 제한을 재정의할 수 있습니다:

`wandb.Table.MAX_ARTIFACT_ROWS = X`

그러나 이 경우 UI에서 쿼리 속도가 느려지는 등 성능 문제가 발생할 수 있습니다.
</Note>

### 프로그램 방식으로 Tables 엑세스

백엔드에서 Tables는 Artifacts로 유지됩니다. 특정 버전에 엑세스하려는 경우 아티팩트 API를 사용하여 수행할 수 있습니다:

```python
with wandb.init() as run:
    my_table = run.use_artifact("run-<run-id>-<table-name>:<tag>").get("<table-name>")
```

Artifacts에 대한 자세한 내용은 개발자 가이드의 [Artifacts 챕터](/models/artifacts/)를 참조하세요.

### Tables 시각화

이러한 방식으로 로그된 모든 테이블은 Run 페이지와 Project 페이지 모두의 Workspace에 표시됩니다. 자세한 내용은 [Tables 시각화 및 분석](/models/tables/visualize-tables/)을 참조하세요.


## Artifact 테이블

Workspace 대신 Run의 Artifacts 섹션에 테이블을 로그하려면 `artifact.add()`를 사용하세요. 이는 한 번 로그한 후 향후 Runs에서 참조하고 싶은 데이터셋이 있는 경우 유용할 수 있습니다.

```python
with wandb.init(project="my_project") as run:
    # 각 의미 있는 단계에 대해 wandb Artifact 생성
    test_predictions = wandb.Artifact("mnist_test_preds", type="predictions")

    # [위와 같이 예측 데이터를 구축합니다]
    test_table = wandb.Table(data=data, columns=columns)
    test_predictions.add(test_table, "my_test_key")
    run.log_artifact(test_predictions)
```

이미지 데이터와 함께 `artifact.add()`를 사용하는 [자세한 예시는 이 Colab](https://wandb.me/dsviz-nature-colab)을 참조하고, Artifacts와 Tables를 사용하여 [테이블 형식 데이터를 버전 관리하고 중복 제거](https://wandb.me/TBV-Dedup)하는 방법은 이 Reports를 참조하세요.

### Artifact 테이블 조인 (Join)

`wandb.JoinedTable(table_1, table_2, join_key)`를 사용하여 로컬에서 생성한 테이블이나 다른 아티팩트에서 가져온 테이블을 조인할 수 있습니다.

| 인수 | 설명 |
| --------- | ------------------------------------------------------------------------------------------------------------------ |
| table_1  | (str, `wandb.Table`, ArtifactEntry) 아티팩트 내 `wandb.Table`의 경로, 테이블 오브젝트 또는 ArtifactEntry |
| table_2  | (str, `wandb.Table`, ArtifactEntry) 아티팩트 내 `wandb.Table`의 경로, 테이블 오브젝트 또는 ArtifactEntry |
| join_key | (str, [str, str]) 조인을 수행할 키 또는 키들 |


이전에 아티팩트 컨텍스트에 로그한 두 개의 Tables를 조인하려면, 아티팩트에서 가져와서 결과를 새 Table로 조인하세요.

예를 들어, 다음 코드 예시는 `'original_songs'`라는 원곡 테이블과 동일한 곡의 합성 버전인 `'synth_songs'`라는 다른 테이블을 읽는 방법을 보여줍니다. 코드는 두 테이블을 `"song_id"`를 기준으로 조인하고, 결과 테이블을 새로운 W&B Table로 업로드합니다:

```python
import wandb

with wandb.init(project="my_project") as run:

    # 원곡 테이블 가져오기
    orig_songs = run.use_artifact("original_songs:latest")
    orig_table = orig_songs.get("original_samples")

    # 합성곡 테이블 가져오기
    synth_songs = run.use_artifact("synth_songs:latest")
    synth_table = synth_songs.get("synth_samples")

    # "song_id"를 기준으로 테이블 조인
    join_table = wandb.JoinedTable(orig_table, synth_table, "song_id")
    join_at = wandb.Artifact("synth_summary", "analysis")

    # 아티팩트에 테이블 추가 및 W&B에 로그
    join_at.add(join_table, "synth_explore")
    run.log_artifact(join_at)
```

서로 다른 Artifact 오브젝트에 저장된 이전에 저장된 두 테이블을 결합하는 방법에 대한 예시는 [이 튜토리얼](https://wandb.ai/stacey/cshanty/reports/Whale2Song-W-B-Tables-for-Audio--Vmlldzo4NDI3NzM)을 읽어보세요.