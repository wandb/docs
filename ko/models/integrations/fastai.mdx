---
title: fastai
---

import ApiKeyCreateStreamlined from "/snippets/ko/_includes/api-key-create-streamlined.mdx";

`WandbCallback` 클래스를 사용하여 **fastai**를 W&amp;B와 연동할 수 있습니다. 자세한 내용은 [예제가 포함된 대화형 문서](https://app.wandb.ai/borisd13/demo_config/reports/Visualize-track-compare-Fastai-models--Vmlldzo4MzAyNA)를 확인하세요.

<div id="sign-up-and-create-an-api-key">
  ## 가입 및 API 키 생성
</div>

API 키는 사용자의 머신을 W&amp;B에 인증하는 데 사용됩니다. 사용자 프로필에서 API 키를 생성할 수 있습니다.

<ApiKeyCreateStreamlined />

1. 오른쪽 상단에 있는 사용자 프로필 아이콘을 클릭합니다.
2. **User Settings**를 선택한 다음, 아래로 스크롤하여 **API Keys** 섹션을 찾습니다.

<div id="install-the-wandb-library-and-log-in">
  ## `wandb` 라이브러리를 설치하고 로그인하기
</div>

로컬 환경에 `wandb` 라이브러리를 설치하고 로그인하려면:

<Tabs>
  <Tab title="Command Line">
    1. `WANDB_API_KEY` [environment variable](/ko/models/track/environment-variables/)을(를) 자신의 API 키로 설정합니다.

       ```bash
       export WANDB_API_KEY=<your_api_key>
       ```

    2. `wandb` 라이브러리를 설치하고 로그인합니다.

       ```shell
       pip install wandb

       wandb login
       ```
  </Tab>

  <Tab title="Python">
    ```bash
    pip install wandb
    ```

    ```python
    import wandb
    wandb.login()
    ```
  </Tab>

  <Tab title="Python notebook">
    ```notebook
    !pip install wandb

    import wandb
    wandb.login()
    ```
  </Tab>
</Tabs>

<div id="add-the-wandbcallback-to-the-learner-or-fit-method">
  ## `WandbCallback`을 `learner` 또는 `fit` 메서드에 추가
</div>

```python
import wandb
from fastai.callback.wandb import *

# wandb run 로깅 시작
wandb.init(project="my_project")

# 하나의 트레이닝 단계에서만 로깅하려면
learn.fit(..., cbs=WandbCallback())

# 모든 트레이닝 단계에서 지속적으로 로깅하려면
learn = learner(..., cbs=WandbCallback())
```

<Note>
  Fastai v1을 사용하는 경우 [Fastai v1 문서](/ko/models/integrations/fastai/v1/)를 참조하세요.
</Note>

<div id="wandbcallback-arguments">
  ## WandbCallback 인자
</div>

`WandbCallback`은(는) 다음 인자를 받습니다:

| Args                     | Description                                                                                                                                                                                                                                                  |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| log                      | 모델의 `gradients`, `parameters`, `all` 또는 `None`(기본값)을 로깅할지 여부입니다. 손실과 메트릭은 항상 로깅됩니다.                                                                                                                                  |
| log&#95;preds               | 예측 샘플을 로깅할지 여부입니다(기본값은 `True`).                                                                                                                                                                                               |
| log&#95;preds&#95;every&#95;epoch | 매 에포크마다 예측을 로깅할지, 아니면 마지막에만 로깅할지 여부입니다(기본값은 `False`).                                                                                                                                                                                   |
| log&#95;model               | 모델을 로깅할지 여부입니다(기본값은 False). 이 기능을 사용하려면 `SaveModelCallback`이(가) 필요합니다.                                                                                                                                                                  |
| model&#95;name              | 저장할 `file`의 이름입니다. `SaveModelCallback` 설정을 덮어씁니다.                                                                                                                                                                                               |
| log&#95;dataset             | <ul><li><code>False</code> (기본값)</li><li><code>True</code>이면 learn.dls.path가 참조하는 폴더를 로깅합니다.</li><li>로깅할 폴더를 지정하기 위해 경로를 명시적으로 정의할 수 있습니다.</li></ul><p><em>참고: 하위 폴더 &quot;models&quot;는 항상 무시됩니다.</em></p> |
| dataset&#95;name            | 로깅되는 데이터셋의 이름입니다(기본값은 `folder name`).                                                                                                                                                                                                          |
| valid&#95;dl                | 예측 샘플에 사용할 항목을 포함하는 `DataLoaders`입니다(기본값은 `learn.dls.valid`에서 임의로 선택된 항목).                                                                                                                                                 |
| n&#95;preds                 | 로깅할 예측 개수입니다(기본값은 36).                                                                                                                                                                                                                 |
| seed                     | 랜덤 샘플을 정의하는 데 사용됩니다.                                                                                                                                                                                                                             |

사용자 정의 워크플로의 경우, 데이터셋과 모델을 수동으로 로깅할 수 있습니다:

* `log_dataset(path, name=None, metadata={})`
* `log_model(path, name=None, metadata={})`

*참고: 하위 폴더 &quot;models&quot;는 모두 무시됩니다.*

<div id="distributed-training">
  ## 분산 트레이닝
</div>

`fastai`는 컨텍스트 매니저 `distrib_ctx`를 사용해 분산 트레이닝을 지원합니다. W&amp;B는 이를 자동으로 지원하며, 별도 설정 없이 Multi-GPU 실험을 추적할 수 있게 해줍니다.

다음 간단한 예제를 살펴보세요:

<Tabs>
  <Tab title="Script">
    ```python
    import wandb
    from fastai.vision.all import *
    from fastai.distributed import *
    from fastai.callback.wandb import WandbCallback

    wandb.require(experiment="service")
    path = rank0_first(lambda: untar_data(URLs.PETS) / "images")

    def train():
        dls = ImageDataLoaders.from_name_func(
            path,
            get_image_files(path),
            valid_pct=0.2,
            label_func=lambda x: x[0].isupper(),
            item_tfms=Resize(224),
        )
        wandb.init("fastai_ddp", entity="capecape")
        cb = WandbCallback()
        learn = vision_learner(dls, resnet34, metrics=error_rate, cbs=cb).to_fp16()
        with learn.distrib_ctx(sync_bn=False):
            learn.fit(1)

    if __name__ == "__main__":
        train()
    ```

    그런 다음 터미널에서 다음을 실행합니다:

    ```shell
    $ torchrun --nproc_per_node 2 train.py
    ```

    이 경우 사용 중인 머신에는 GPU가 2개 있습니다.
  </Tab>

  <Tab title="Python notebook">
    이제 노트북 내부에서 바로 분산 트레이닝을 실행할 수 있습니다.

    ```python
    import wandb
    from fastai.vision.all import *

    from accelerate import notebook_launcher
    from fastai.distributed import *
    from fastai.callback.wandb import WandbCallback

    wandb.require(experiment="service")
    path = untar_data(URLs.PETS) / "images"

    def train():
        dls = ImageDataLoaders.from_name_func(
            path,
            get_image_files(path),
            valid_pct=0.2,
            label_func=lambda x: x[0].isupper(),
            item_tfms=Resize(224),
        )
        wandb.init("fastai_ddp", entity="capecape")
        cb = WandbCallback()
        learn = vision_learner(dls, resnet34, metrics=error_rate, cbs=cb).to_fp16()
        with learn.distrib_ctx(in_notebook=True, sync_bn=False):
            learn.fit(1)

    notebook_launcher(train, num_processes=2)
    ```
  </Tab>
</Tabs>

<div id="log-only-on-the-main-process">
  ### 메인 프로세스에서만 로깅하기
</div>

위 예시에서 `wandb`는 프로세스당 하나의 run을 실행합니다. 트레이닝이 끝나면 두 개의 run이 생성됩니다. 이는 때때로 혼란스러울 수 있으며, 메인 프로세스에서만 로깅하고 싶을 수 있습니다. 이를 위해서는 현재 프로세스가 메인 프로세스인지 직접 판별하고, 나머지 프로세스들에서는 run을 생성하지 않도록(`wandb.init`을 호출하지 않도록) 해야 합니다.

<Tabs>
  <Tab title="Script">
    ```python
    import wandb
    from fastai.vision.all import *
    from fastai.distributed import *
    from fastai.callback.wandb import WandbCallback

    wandb.require(experiment="service")
    path = rank0_first(lambda: untar_data(URLs.PETS) / "images")

    def train():
        cb = []
        dls = ImageDataLoaders.from_name_func(
            path,
            get_image_files(path),
            valid_pct=0.2,
            label_func=lambda x: x[0].isupper(),
            item_tfms=Resize(224),
        )
        if rank_distrib() == 0:
            run = wandb.init("fastai_ddp", entity="capecape")
            cb = WandbCallback()
        learn = vision_learner(dls, resnet34, metrics=error_rate, cbs=cb).to_fp16()
        with learn.distrib_ctx(sync_bn=False):
            learn.fit(1)

    if __name__ == "__main__":
        train()
    ```

    터미널에서 다음 명령을 실행합니다:

    ```
    $ torchrun --nproc_per_node 2 train.py
    ```
  </Tab>

  <Tab title="Python notebook">
    ```python
    import wandb
    from fastai.vision.all import *

    from accelerate import notebook_launcher
    from fastai.distributed import *
    from fastai.callback.wandb import WandbCallback

    wandb.require(experiment="service")
    path = untar_data(URLs.PETS) / "images"

    def train():
        cb = []
        dls = ImageDataLoaders.from_name_func(
            path,
            get_image_files(path),
            valid_pct=0.2,
            label_func=lambda x: x[0].isupper(),
            item_tfms=Resize(224),
        )
        if rank_distrib() == 0:
            run = wandb.init("fastai_ddp", entity="capecape")
            cb = WandbCallback()
        learn = vision_learner(dls, resnet34, metrics=error_rate, cbs=cb).to_fp16()
        with learn.distrib_ctx(in_notebook=True, sync_bn=False):
            learn.fit(1)

    notebook_launcher(train, num_processes=2)
    ```
  </Tab>
</Tabs>

<div id="examples">
  ## 예시
</div>

* [Fastai 모델 시각화, 추적, 비교](https://app.wandb.ai/borisd13/demo_config/reports/Visualize-track-compare-Fastai-models--Vmlldzo4MzAyNA): 자세히 설명된 워크스루입니다.
* [CamVid에서의 이미지 세그멘테이션](https://bit.ly/fastai-wandb): 인테그레이션의 대표적인 사용 사례입니다.