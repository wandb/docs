---
title: run 초기화
---

[`wandb.init()`](/ko/models/ref/python/functions/init)으로 W&amp;B Run을 초기화합니다.

기본적으로 W&amp;B는 `wandb.init()`을 호출할 때 각 Python 프로세스에 동시에 하나의 활성 run만 존재한다고 가정합니다. `wandb.init()`을 다시 호출하면 W&amp;B는 동일한 run을 반환하거나, 기존 run을 종료한 후 새 run을 시작합니다. 동일한 프로세스에서 `wandb.init()`을 여러 번 호출했을 때 이를 처리하는 방식은 환경(노트북 vs 비노트북)과 `reinit` 설정에 따라 달라집니다.

동일한 프로세스에서 여러 개의 활성 run을 관리하려면 [하나의 프로세스에서 여러 run 사용](/ko/models/runs/initialize-run#multiple-runs-in-one-process)을 참조하세요.

<Note>
  W&amp;B는 `wandb.init()`을 호출할 때 `with` 블록을 사용할 것을 권장합니다. 이렇게 하면 블록이 끝날 때 W&amp;B가 run을 올바르게 종료하고 모든 데이터를 업로드하는 것이 보장됩니다.
</Note>

<div id="single-run-per-process">
  ## 프로세스당 하나의 run
</div>

다음 예제 코드 스니펫은 W&amp;B Python SDK를 import한 후 run을 초기화하는 방법을 보여줍니다.

```python title="basic.py"
import wandb

with wandb.init(entity="nico", project="awesome-project") as run:
    # 여기에 트레이닝 로직을 작성하세요
```

다음은 이 코드 스니펫의 출력입니다:

```bash
🚀 View run exalted-darkness-6 at: 
https://wandb.ai/nico/awesome-project/runs/pgbn9y21
Find logs at: wandb/run-20241106_090747-pgbn9y21/logs
```

출력 결과를 보면 W&amp;B가 엔티티 `nico`의 프로젝트 `awesome-project`에 run `exalted-darkness-6`을(를) 기록했음을 알 수 있습니다. `pgbn9y21`은(는) 이 run에 대해 W&amp;B가 생성한 고유 run ID입니다.

<div id="multiple-runs-in-one-process">
  ## 하나의 프로세스에서 여러 run 사용
</div>

단일 Python 프로세스에서 여러 run을 관리할 수 있습니다. 이는 기본 프로세스를 계속 활성 상태로 유지하면서, 하위 작업을 위해 단기 보조 프로세스를 생성해야 하는 워크플로에서 유용합니다. 예를 들면 다음과 같습니다:

* 스크립트 전체에서 하나의 “기본(primary)” run을 계속 활성 상태로 유지하면서, 평가나 하위 작업을 위해 짧게 실행되는 “보조(secondary)” run을 여러 개 띄우는 경우
* 하나의 파일에서 여러 하위 실험을 오케스트레이션하는 경우
* 하나의 “메인” 프로세스에서 여러 개의 run으로 로깅하되, 각 run이 서로 다른 작업 또는 기간을 나타내도록 하는 경우

기본적으로 W&amp;B는 `wandb.init()`을 호출할 때 각 Python 프로세스에 동시에 하나의 활성 run만 있다고 가정합니다. `wandb.init()`을 다시 호출하면, 설정에 따라 W&amp;B는 동일한 run을 반환하거나, 새로운 run을 시작하기 전에 기존 run을 종료합니다.

이 가이드는 단일 Python 프로세스에서 여러 run을 사용할 수 있도록 `reinit`을 사용해 `wandb.init()` 동작을 변경하는 방법을 설명합니다.

<Note>
  **요구 사항**

  단일 Python 프로세스에서 여러 run을 관리하려면 W&amp;B Python SDK 버전이 `v0.19.10` 이상이어야 합니다.
</Note>

<div id="reinit-options">
  ### `reinit` 옵션
</div>

`reinit` 파라미터를 사용해 W&amp;B가 `wandb.init()`를 여러 번 호출하는 경우를 어떻게 처리할지 설정할 수 있습니다. 아래 표는 허용되는 인자 값과 그 효과를 설명합니다:

| | 설명 | run을 생성하나요? | 사용 예 |
|----------------|----------------|----------------| -----------------|
| `create_new` | 기존에 활성 상태인 run들을 종료하지 않고 `wandb.init()`으로 새 run을 생성합니다. W&amp;B는 전역 `wandb.Run`을 새 run으로 자동 전환하지 않습니다. 각 run 객체를 직접 보관해야 합니다. 자세한 내용은 아래의 [한 프로세스에서 여러 run 실행 예시](/ko/models/runs/initialize-run/#example-multiple-runs-in-one-process)를 참고하세요.  | Yes | 동시에 실행되는 프로세스를 생성하고 관리하기에 적합합니다. 예를 들어, “primary” run을 계속 활성 상태로 유지하면서 “secondary” run들을 시작하거나 종료하는 경우에 사용할 수 있습니다.|
| `finish_previous` | 새 run을 `wandb.init()`으로 생성하기 전에 활성 상태인 모든 run에 대해 `run.finish()`를 호출해 종료합니다. 노트북이 아닌 환경에서의 기본 동작입니다. | Yes | 순차적인 하위 프로세스를 개별 run으로 나누고 싶을 때 적합합니다. |
| `return_previous` | 가장 최근의 아직 종료되지 않은 run을 반환합니다. 노트북 환경에서의 기본 동작입니다. | No | |

<Note>
  W&amp;B는 Hugging Face Trainer, Keras callbacks, PyTorch Lightning처럼 단일 전역 run을 가정하는 [W&amp;B Integrations](/ko/models/integrations)에 대해 `create_new` 모드를 지원하지 않습니다. 이러한 인테그레이션을 사용하는 경우에는 각 하위 실험을 별도의 프로세스에서 실행해야 합니다.
</Note>

<div id="specifying-reinit">
  ### `reinit` 설정하기
</div>

{/* 하나의 Python 프로세스 내에서 여러 run을 생성하고 관리하는 방법이 여러 가지 있습니다. */}

* `reinit` 인수를 사용해 `wandb.init()`을 직접 호출합니다:
  ```python
  import wandb
  with wandb.init(reinit="<create_new|finish_previous|return_previous>") as run:
      # 여기에 코드를 작성하세요
  ```

* `wandb.init()`를 사용하고, `settings` 매개변수에 `wandb.Settings` 객체를 전달합니다. `Settings` 객체에서 `reinit` 값을 지정합니다:

  ```python
  import wandb
  with wandb.init(settings=wandb.Settings(reinit="<create_new|finish_previous|return_previous>")) as run:
      # 여기에 코드를 작성하세요
  ```

* 현재 프로세스에서 생성되는 모든 run에 대해 전역적으로 `reinit` 옵션을 설정하려면 `wandb.setup()`을 사용합니다. 이는 동작 방식을 한 번만 설정해 두고, 이후 해당 프로세스에서 호출되는 모든 `wandb.init()`에 동일하게 적용되도록 할 때 유용합니다.

  ```python
  import wandb
  with wandb.setup(wandb.Settings(reinit="<create_new|finish_previous|return_previous>")) as run:
       # 여기에 코드를 작성하세요
  ```

* 환경 변수 `WANDB_REINIT`에 원하는 `reinit` 값을 지정합니다. 환경 변수를 정의하면 `wandb.init()` 호출에 `reinit` 옵션이 적용됩니다.

  ```bash
  export WANDB_REINIT="<create_new|finish_previous|return_previous>"
  ```

다음 코드 조각은 `wandb.init()`를 호출할 때마다 새 run을 생성하도록 W&amp;B를 설정하는 방법을 개략적으로 보여줍니다:

```python
import wandb

wandb.setup(wandb.Settings(reinit="create_new"))

with wandb.init() as experiment_results_run:
    # 이 run은 각 실험의 결과를 기록하는 데 사용됩니다.
    # 결과를 수집하는 상위 run으로 생각할 수 있습니다.
      with wandb.init() as run:
         # do_experiment() 함수는 세분화된 메트릭을 지정된 run에 기록하고,
         # 별도로 추적하려는 결과 메트릭을 반환합니다.
         experiment_results = do_experiment(run)

         # 각 실험 후, 결과를 상위 run에 기록합니다.
         # 상위 run의 차트에서 각 점은 하나의 실험 결과에 해당합니다.
         experiment_results_run.log(experiment_results)
```

<div id="example-concurrent-processes">
  ### 예시: 동시 실행 프로세스
</div>

스크립트의 전체 수명 동안 열린 상태로 유지되는 기본 프로세스를 하나 두고, 이 기본 프로세스를 종료하지 않은 채 주기적으로 수명이 짧은 보조 프로세스를 생성하고 싶다고 가정해 보겠습니다. 예를 들어, 이 패턴은 기본 run에서 모델을 트레이닝하면서, 별도의 run들에서 평가를 수행하거나 다른 작업을 하고 싶을 때 유용합니다.

이를 위해 `reinit="create_new"`를 사용해 여러 run을 초기화합니다. 이 예시에서는 스크립트 전체 동안 열린 상태로 유지되는 기본 프로세스를 &quot;Run A&quot;라고 하고, &quot;Run B1&quot;, &quot;Run B2&quot;는 평가 같은 작업을 위한 수명이 짧은 보조 run이라고 가정합니다.

상위 수준 워크플로는 대략 다음과 같습니다:

1. `wandb.init()`으로 기본 프로세스 Run A를 초기화하고 트레이닝 메트릭을 기록합니다.
2. `wandb.init()`으로 Run B1을 초기화하고 데이터를 기록한 뒤, 해당 run을 종료합니다.
3. Run A에 더 많은 데이터를 기록합니다.
4. Run B2를 초기화하고 데이터를 기록한 뒤, 해당 run을 종료합니다.
5. Run A에 계속해서 로그를 기록합니다.
6. 마지막에 Run A를 종료합니다.

다음 Python 코드 예제는 이 워크플로를 보여줍니다:

```python
import wandb

def train(name: str) -> None:
    """자체 W&B run에서 트레이닝을 한 번 수행합니다.

    `reinit="create_new"`와 함께 'with wandb.init()' 블록을 사용하면
    다른 run(기본 추적 run 등)이 이미 활성 상태인 경우에도
    이 트레이닝 서브 run을 생성할 수 있습니다.
    """
    with wandb.init(
        project="my_project",
        name=name,
        reinit="create_new"
    ) as run:
        # 실제 스크립트에서는 이 블록 안에서 트레이닝 단계를 실행합니다.
        run.log({"train_loss": 0.42})  # 실제 메트릭으로 교체하세요

def evaluate_loss_accuracy() -> (float, float):
    """현재 모델의 손실 및 정확도를 반환합니다.
    
    이 플레이스홀더를 실제 평가 로직으로 교체하세요.
    """
    return 0.27, 0.91  # 예시 메트릭 값

# 여러 트레이닝/평가 단계 동안 활성 상태를 유지하는 '기본' run을 생성합니다.
with wandb.init(
    project="my_project",
    name="tracking_run",
    reinit="create_new"
) as tracking_run:
    # 1) 'training_1'이라는 서브 run에서 트레이닝을 한 번 실행합니다
    train("training_1")
    loss, accuracy = evaluate_loss_accuracy()
    tracking_run.log({"eval_loss": loss, "eval_accuracy": accuracy})

    # 2) 'training_2'라는 서브 run에서 트레이닝을 다시 실행합니다
    train("training_2")
    loss, accuracy = evaluate_loss_accuracy()
    tracking_run.log({"eval_loss": loss, "eval_accuracy": accuracy})
    
    # 이 'with' 블록이 종료되면 'tracking_run'이 자동으로 완료됩니다.
```

이전 예제에서 다음 세 가지 핵심 사항을 유의하세요:

1. `reinit="create_new"`는 `wandb.init()`을 호출할 때마다 새 run을 생성합니다.
2. 각 run에 대한 참조를 유지해야 합니다. `wandb.run`은 `reinit="create_new"`로 생성된 새 run을 자동으로 가리키지 않습니다. 새 run은 `run_a`, `run_b1` 등과 같은 변수에 저장하고, 필요에 따라 해당 객체에서 `.log()` 또는 `.finish()`를 호출하세요.
3. 기본 run은 계속 열어 둔 채, 서브 run은 원하는 때에 언제든지 종료할 수 있습니다.
4. 해당 run에 대한 로깅을 모두 마쳤다면 `run.finish()`로 run을 종료하세요. 이렇게 하면 모든 데이터가 업로드되고 run이 올바르게 종료됩니다.
